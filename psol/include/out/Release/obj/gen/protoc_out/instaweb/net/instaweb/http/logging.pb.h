// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net/instaweb/http/logging.proto

#ifndef PROTOBUF_net_2finstaweb_2fhttp_2flogging_2eproto__INCLUDED
#define PROTOBUF_net_2finstaweb_2fhttp_2flogging_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "net/instaweb/rewriter/image_types.pb.h"
// @@protoc_insertion_point(includes)

namespace net_instaweb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();

class TimingInfo;
class BlinkInfo;
class MetadataCacheInfo;
class RewritingInfo;
class SplitHtmlInfo;
class PropertyCohortInfo;
class PropertyPageInfo;
class FlushEarlyFlowInfo;
class FlushEarlyResourceInfo;
class CriticalCssInfo;
class CacheHtmlLoggingInfo;
class RewriteResourceInfo;
class ImageRewriteResourceInfo;
class RewriterInfo;
class ResourceUrlInfo;
class ImageStats;
class RewriteStatusCount;
class RewriterStats;
class DeviceInfo;
class LoggingInfo;

enum BlinkInfo_BlinkRequestFlow {
  BlinkInfo_BlinkRequestFlow_BLINK_CACHE_HIT = 1,
  BlinkInfo_BlinkRequestFlow_BLINK_CACHE_MISS_FOUND_RESOURCE = 2,
  BlinkInfo_BlinkRequestFlow_BLINK_CACHE_MISS_FETCH_NON_OK = 3,
  BlinkInfo_BlinkRequestFlow_BLINK_CACHE_MISS_TRIGGERED_REWRITE = 4,
  BlinkInfo_BlinkRequestFlow_FOUND_MALFORMED_HTML = 5,
  BlinkInfo_BlinkRequestFlow_FOUND_LAST_STATUS_CODE_NON_OK = 6,
  BlinkInfo_BlinkRequestFlow_FOUND_CONTENT_LENGTH_OVER_THRESHOLD = 7,
  BlinkInfo_BlinkRequestFlow_BLINK_BLACKLISTED = 8
};
bool BlinkInfo_BlinkRequestFlow_IsValid(int value);
const BlinkInfo_BlinkRequestFlow BlinkInfo_BlinkRequestFlow_BlinkRequestFlow_MIN = BlinkInfo_BlinkRequestFlow_BLINK_CACHE_HIT;
const BlinkInfo_BlinkRequestFlow BlinkInfo_BlinkRequestFlow_BlinkRequestFlow_MAX = BlinkInfo_BlinkRequestFlow_BLINK_BLACKLISTED;
const int BlinkInfo_BlinkRequestFlow_BlinkRequestFlow_ARRAYSIZE = BlinkInfo_BlinkRequestFlow_BlinkRequestFlow_MAX + 1;

enum BlinkInfo_UserAgent {
  BlinkInfo_UserAgent_NOT_SET = 0,
  BlinkInfo_UserAgent_BLINK_DESKTOP_WHITELIST = 1,
  BlinkInfo_UserAgent_BLINK_DESKTOP_BLACKLIST = 2,
  BlinkInfo_UserAgent_BLINK_MOBILE = 3,
  BlinkInfo_UserAgent_NULL_OR_EMPTY = 4,
  BlinkInfo_UserAgent_NOT_SUPPORT_BLINK = 5
};
bool BlinkInfo_UserAgent_IsValid(int value);
const BlinkInfo_UserAgent BlinkInfo_UserAgent_UserAgent_MIN = BlinkInfo_UserAgent_NOT_SET;
const BlinkInfo_UserAgent BlinkInfo_UserAgent_UserAgent_MAX = BlinkInfo_UserAgent_NOT_SUPPORT_BLINK;
const int BlinkInfo_UserAgent_UserAgent_ARRAYSIZE = BlinkInfo_UserAgent_UserAgent_MAX + 1;

enum FlushEarlyResourceInfo_ResourceType {
  FlushEarlyResourceInfo_ResourceType_UNKNOWN_TYPE = 0,
  FlushEarlyResourceInfo_ResourceType_PAGESPEED = 1,
  FlushEarlyResourceInfo_ResourceType_NON_PAGESPEED = 2,
  FlushEarlyResourceInfo_ResourceType_PRIVATE_CACHEABLE = 3,
  FlushEarlyResourceInfo_ResourceType_DEFERJS_SCRIPT = 4
};
bool FlushEarlyResourceInfo_ResourceType_IsValid(int value);
const FlushEarlyResourceInfo_ResourceType FlushEarlyResourceInfo_ResourceType_ResourceType_MIN = FlushEarlyResourceInfo_ResourceType_UNKNOWN_TYPE;
const FlushEarlyResourceInfo_ResourceType FlushEarlyResourceInfo_ResourceType_ResourceType_MAX = FlushEarlyResourceInfo_ResourceType_DEFERJS_SCRIPT;
const int FlushEarlyResourceInfo_ResourceType_ResourceType_ARRAYSIZE = FlushEarlyResourceInfo_ResourceType_ResourceType_MAX + 1;

enum FlushEarlyResourceInfo_ContentType {
  FlushEarlyResourceInfo_ContentType_UNKNOWN_CONTENT_TYPE = 0,
  FlushEarlyResourceInfo_ContentType_IMAGE = 1,
  FlushEarlyResourceInfo_ContentType_JS = 2,
  FlushEarlyResourceInfo_ContentType_CSS = 3
};
bool FlushEarlyResourceInfo_ContentType_IsValid(int value);
const FlushEarlyResourceInfo_ContentType FlushEarlyResourceInfo_ContentType_ContentType_MIN = FlushEarlyResourceInfo_ContentType_UNKNOWN_CONTENT_TYPE;
const FlushEarlyResourceInfo_ContentType FlushEarlyResourceInfo_ContentType_ContentType_MAX = FlushEarlyResourceInfo_ContentType_CSS;
const int FlushEarlyResourceInfo_ContentType_ContentType_ARRAYSIZE = FlushEarlyResourceInfo_ContentType_ContentType_MAX + 1;

enum CacheHtmlLoggingInfo_CacheHtmlRequestFlow {
  CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CACHE_HTML_HIT = 1,
  CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CACHE_HTML_MISS_FOUND_RESOURCE = 2,
  CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CACHE_HTML_MISS_FETCH_NON_OK = 3,
  CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CACHE_HTML_MISS_TRIGGERED_REWRITE = 4,
  CacheHtmlLoggingInfo_CacheHtmlRequestFlow_FOUND_MALFORMED_HTML = 5,
  CacheHtmlLoggingInfo_CacheHtmlRequestFlow_FOUND_CONTENT_LENGTH_OVER_THRESHOLD = 6
};
bool CacheHtmlLoggingInfo_CacheHtmlRequestFlow_IsValid(int value);
const CacheHtmlLoggingInfo_CacheHtmlRequestFlow CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CacheHtmlRequestFlow_MIN = CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CACHE_HTML_HIT;
const CacheHtmlLoggingInfo_CacheHtmlRequestFlow CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CacheHtmlRequestFlow_MAX = CacheHtmlLoggingInfo_CacheHtmlRequestFlow_FOUND_CONTENT_LENGTH_OVER_THRESHOLD;
const int CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CacheHtmlRequestFlow_ARRAYSIZE = CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CacheHtmlRequestFlow_MAX + 1;

enum RewriterInfo_RewriterApplicationStatus {
  RewriterInfo_RewriterApplicationStatus_UNKNOWN_STATUS = 0,
  RewriterInfo_RewriterApplicationStatus_APPLIED_OK = 1,
  RewriterInfo_RewriterApplicationStatus_NOT_APPLIED = 2,
  RewriterInfo_RewriterApplicationStatus_PROPERTY_NOT_FOUND = 3,
  RewriterInfo_RewriterApplicationStatus_INPUT_URL_INVALID = 4,
  RewriterInfo_RewriterApplicationStatus_REPLACE_FAILED = 5
};
bool RewriterInfo_RewriterApplicationStatus_IsValid(int value);
const RewriterInfo_RewriterApplicationStatus RewriterInfo_RewriterApplicationStatus_RewriterApplicationStatus_MIN = RewriterInfo_RewriterApplicationStatus_UNKNOWN_STATUS;
const RewriterInfo_RewriterApplicationStatus RewriterInfo_RewriterApplicationStatus_RewriterApplicationStatus_MAX = RewriterInfo_RewriterApplicationStatus_REPLACE_FAILED;
const int RewriterInfo_RewriterApplicationStatus_RewriterApplicationStatus_ARRAYSIZE = RewriterInfo_RewriterApplicationStatus_RewriterApplicationStatus_MAX + 1;

enum RewriterStats_RewriterHtmlStatus {
  RewriterStats_RewriterHtmlStatus_UNKNOWN_STATUS = 0,
  RewriterStats_RewriterHtmlStatus_ACTIVE = 1,
  RewriterStats_RewriterHtmlStatus_DISABLED = 2,
  RewriterStats_RewriterHtmlStatus_PROPERTY_CACHE_MISS = 3,
  RewriterStats_RewriterHtmlStatus_USER_AGENT_NOT_SUPPORTED = 4
};
bool RewriterStats_RewriterHtmlStatus_IsValid(int value);
const RewriterStats_RewriterHtmlStatus RewriterStats_RewriterHtmlStatus_RewriterHtmlStatus_MIN = RewriterStats_RewriterHtmlStatus_UNKNOWN_STATUS;
const RewriterStats_RewriterHtmlStatus RewriterStats_RewriterHtmlStatus_RewriterHtmlStatus_MAX = RewriterStats_RewriterHtmlStatus_USER_AGENT_NOT_SUPPORTED;
const int RewriterStats_RewriterHtmlStatus_RewriterHtmlStatus_ARRAYSIZE = RewriterStats_RewriterHtmlStatus_RewriterHtmlStatus_MAX + 1;

// ===================================================================

class TimingInfo : public ::google::protobuf::MessageLite {
 public:
  TimingInfo();
  virtual ~TimingInfo();
  
  TimingInfo(const TimingInfo& from);
  
  inline TimingInfo& operator=(const TimingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const TimingInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TimingInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(TimingInfo* other);
  
  // implements Message ----------------------------------------------
  
  TimingInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimingInfo& from);
  void MergeFrom(const TimingInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 cache1_ms = 1;
  inline bool has_cache1_ms() const;
  inline void clear_cache1_ms();
  static const int kCache1MsFieldNumber = 1;
  inline ::google::protobuf::int64 cache1_ms() const;
  inline void set_cache1_ms(::google::protobuf::int64 value);
  
  // optional int64 cache2_ms = 2;
  inline bool has_cache2_ms() const;
  inline void clear_cache2_ms();
  static const int kCache2MsFieldNumber = 2;
  inline ::google::protobuf::int64 cache2_ms() const;
  inline void set_cache2_ms(::google::protobuf::int64 value);
  
  // optional int64 header_fetch_ms = 3;
  inline bool has_header_fetch_ms() const;
  inline void clear_header_fetch_ms();
  static const int kHeaderFetchMsFieldNumber = 3;
  inline ::google::protobuf::int64 header_fetch_ms() const;
  inline void set_header_fetch_ms(::google::protobuf::int64 value);
  
  // optional int64 fetch_ms = 4;
  inline bool has_fetch_ms() const;
  inline void clear_fetch_ms();
  static const int kFetchMsFieldNumber = 4;
  inline ::google::protobuf::int64 fetch_ms() const;
  inline void set_fetch_ms(::google::protobuf::int64 value);
  
  // optional int64 time_to_first_byte_ms = 5;
  inline bool has_time_to_first_byte_ms() const;
  inline void clear_time_to_first_byte_ms();
  static const int kTimeToFirstByteMsFieldNumber = 5;
  inline ::google::protobuf::int64 time_to_first_byte_ms() const;
  inline void set_time_to_first_byte_ms(::google::protobuf::int64 value);
  
  // optional int64 request_start_ms = 6;
  inline bool has_request_start_ms() const;
  inline void clear_request_start_ms();
  static const int kRequestStartMsFieldNumber = 6;
  inline ::google::protobuf::int64 request_start_ms() const;
  inline void set_request_start_ms(::google::protobuf::int64 value);
  
  // optional int64 time_to_start_parse_ms = 7;
  inline bool has_time_to_start_parse_ms() const;
  inline void clear_time_to_start_parse_ms();
  static const int kTimeToStartParseMsFieldNumber = 7;
  inline ::google::protobuf::int64 time_to_start_parse_ms() const;
  inline void set_time_to_start_parse_ms(::google::protobuf::int64 value);
  
  // optional int64 time_to_start_fetch_ms = 8;
  inline bool has_time_to_start_fetch_ms() const;
  inline void clear_time_to_start_fetch_ms();
  static const int kTimeToStartFetchMsFieldNumber = 8;
  inline ::google::protobuf::int64 time_to_start_fetch_ms() const;
  inline void set_time_to_start_fetch_ms(::google::protobuf::int64 value);
  
  // optional int64 processing_time_ms = 9;
  inline bool has_processing_time_ms() const;
  inline void clear_processing_time_ms();
  static const int kProcessingTimeMsFieldNumber = 9;
  inline ::google::protobuf::int64 processing_time_ms() const;
  inline void set_processing_time_ms(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.TimingInfo)
 private:
  inline void set_has_cache1_ms();
  inline void clear_has_cache1_ms();
  inline void set_has_cache2_ms();
  inline void clear_has_cache2_ms();
  inline void set_has_header_fetch_ms();
  inline void clear_has_header_fetch_ms();
  inline void set_has_fetch_ms();
  inline void clear_has_fetch_ms();
  inline void set_has_time_to_first_byte_ms();
  inline void clear_has_time_to_first_byte_ms();
  inline void set_has_request_start_ms();
  inline void clear_has_request_start_ms();
  inline void set_has_time_to_start_parse_ms();
  inline void clear_has_time_to_start_parse_ms();
  inline void set_has_time_to_start_fetch_ms();
  inline void clear_has_time_to_start_fetch_ms();
  inline void set_has_processing_time_ms();
  inline void clear_has_processing_time_ms();
  
  ::google::protobuf::int64 cache1_ms_;
  ::google::protobuf::int64 cache2_ms_;
  ::google::protobuf::int64 header_fetch_ms_;
  ::google::protobuf::int64 fetch_ms_;
  ::google::protobuf::int64 time_to_first_byte_ms_;
  ::google::protobuf::int64 request_start_ms_;
  ::google::protobuf::int64 time_to_start_parse_ms_;
  ::google::protobuf::int64 time_to_start_fetch_ms_;
  ::google::protobuf::int64 processing_time_ms_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static TimingInfo* default_instance_;
};
// -------------------------------------------------------------------

class BlinkInfo : public ::google::protobuf::MessageLite {
 public:
  BlinkInfo();
  virtual ~BlinkInfo();
  
  BlinkInfo(const BlinkInfo& from);
  
  inline BlinkInfo& operator=(const BlinkInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BlinkInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BlinkInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(BlinkInfo* other);
  
  // implements Message ----------------------------------------------
  
  BlinkInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BlinkInfo& from);
  void MergeFrom(const BlinkInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef BlinkInfo_BlinkRequestFlow BlinkRequestFlow;
  static const BlinkRequestFlow BLINK_CACHE_HIT = BlinkInfo_BlinkRequestFlow_BLINK_CACHE_HIT;
  static const BlinkRequestFlow BLINK_CACHE_MISS_FOUND_RESOURCE = BlinkInfo_BlinkRequestFlow_BLINK_CACHE_MISS_FOUND_RESOURCE;
  static const BlinkRequestFlow BLINK_CACHE_MISS_FETCH_NON_OK = BlinkInfo_BlinkRequestFlow_BLINK_CACHE_MISS_FETCH_NON_OK;
  static const BlinkRequestFlow BLINK_CACHE_MISS_TRIGGERED_REWRITE = BlinkInfo_BlinkRequestFlow_BLINK_CACHE_MISS_TRIGGERED_REWRITE;
  static const BlinkRequestFlow FOUND_MALFORMED_HTML = BlinkInfo_BlinkRequestFlow_FOUND_MALFORMED_HTML;
  static const BlinkRequestFlow FOUND_LAST_STATUS_CODE_NON_OK = BlinkInfo_BlinkRequestFlow_FOUND_LAST_STATUS_CODE_NON_OK;
  static const BlinkRequestFlow FOUND_CONTENT_LENGTH_OVER_THRESHOLD = BlinkInfo_BlinkRequestFlow_FOUND_CONTENT_LENGTH_OVER_THRESHOLD;
  static const BlinkRequestFlow BLINK_BLACKLISTED = BlinkInfo_BlinkRequestFlow_BLINK_BLACKLISTED;
  static inline bool BlinkRequestFlow_IsValid(int value) {
    return BlinkInfo_BlinkRequestFlow_IsValid(value);
  }
  static const BlinkRequestFlow BlinkRequestFlow_MIN =
    BlinkInfo_BlinkRequestFlow_BlinkRequestFlow_MIN;
  static const BlinkRequestFlow BlinkRequestFlow_MAX =
    BlinkInfo_BlinkRequestFlow_BlinkRequestFlow_MAX;
  static const int BlinkRequestFlow_ARRAYSIZE =
    BlinkInfo_BlinkRequestFlow_BlinkRequestFlow_ARRAYSIZE;
  
  typedef BlinkInfo_UserAgent UserAgent;
  static const UserAgent NOT_SET = BlinkInfo_UserAgent_NOT_SET;
  static const UserAgent BLINK_DESKTOP_WHITELIST = BlinkInfo_UserAgent_BLINK_DESKTOP_WHITELIST;
  static const UserAgent BLINK_DESKTOP_BLACKLIST = BlinkInfo_UserAgent_BLINK_DESKTOP_BLACKLIST;
  static const UserAgent BLINK_MOBILE = BlinkInfo_UserAgent_BLINK_MOBILE;
  static const UserAgent NULL_OR_EMPTY = BlinkInfo_UserAgent_NULL_OR_EMPTY;
  static const UserAgent NOT_SUPPORT_BLINK = BlinkInfo_UserAgent_NOT_SUPPORT_BLINK;
  static inline bool UserAgent_IsValid(int value) {
    return BlinkInfo_UserAgent_IsValid(value);
  }
  static const UserAgent UserAgent_MIN =
    BlinkInfo_UserAgent_UserAgent_MIN;
  static const UserAgent UserAgent_MAX =
    BlinkInfo_UserAgent_UserAgent_MAX;
  static const int UserAgent_ARRAYSIZE =
    BlinkInfo_UserAgent_UserAgent_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional .net_instaweb.BlinkInfo.BlinkRequestFlow blink_request_flow = 1;
  inline bool has_blink_request_flow() const;
  inline void clear_blink_request_flow();
  static const int kBlinkRequestFlowFieldNumber = 1;
  inline ::net_instaweb::BlinkInfo_BlinkRequestFlow blink_request_flow() const;
  inline void set_blink_request_flow(::net_instaweb::BlinkInfo_BlinkRequestFlow value);
  
  // optional string request_event_id_time_usec = 2;
  inline bool has_request_event_id_time_usec() const;
  inline void clear_request_event_id_time_usec();
  static const int kRequestEventIdTimeUsecFieldNumber = 2;
  inline const ::std::string& request_event_id_time_usec() const;
  inline void set_request_event_id_time_usec(const ::std::string& value);
  inline void set_request_event_id_time_usec(const char* value);
  inline void set_request_event_id_time_usec(const char* value, size_t size);
  inline ::std::string* mutable_request_event_id_time_usec();
  inline ::std::string* release_request_event_id_time_usec();
  
  // optional bool html_match = 3;
  inline bool has_html_match() const;
  inline void clear_html_match();
  static const int kHtmlMatchFieldNumber = 3;
  inline bool html_match() const;
  inline void set_html_match(bool value);
  
  // optional .net_instaweb.BlinkInfo.UserAgent blink_user_agent = 4;
  inline bool has_blink_user_agent() const;
  inline void clear_blink_user_agent();
  static const int kBlinkUserAgentFieldNumber = 4;
  inline ::net_instaweb::BlinkInfo_UserAgent blink_user_agent() const;
  inline void set_blink_user_agent(::net_instaweb::BlinkInfo_UserAgent value);
  
  // optional string url = 5;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 5;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // optional bool html_smart_diff_match = 6;
  inline bool has_html_smart_diff_match() const;
  inline void clear_html_smart_diff_match();
  static const int kHtmlSmartDiffMatchFieldNumber = 6;
  inline bool html_smart_diff_match() const;
  inline void set_html_smart_diff_match(bool value);
  
  // optional bool mismatch_blacklist_threshold_exceeded = 7;
  inline bool has_mismatch_blacklist_threshold_exceeded() const;
  inline void clear_mismatch_blacklist_threshold_exceeded();
  static const int kMismatchBlacklistThresholdExceededFieldNumber = 7;
  inline bool mismatch_blacklist_threshold_exceeded() const;
  inline void set_mismatch_blacklist_threshold_exceeded(bool value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.BlinkInfo)
 private:
  inline void set_has_blink_request_flow();
  inline void clear_has_blink_request_flow();
  inline void set_has_request_event_id_time_usec();
  inline void clear_has_request_event_id_time_usec();
  inline void set_has_html_match();
  inline void clear_has_html_match();
  inline void set_has_blink_user_agent();
  inline void clear_has_blink_user_agent();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_html_smart_diff_match();
  inline void clear_has_html_smart_diff_match();
  inline void set_has_mismatch_blacklist_threshold_exceeded();
  inline void clear_has_mismatch_blacklist_threshold_exceeded();
  
  ::std::string* request_event_id_time_usec_;
  int blink_request_flow_;
  int blink_user_agent_;
  ::std::string* url_;
  bool html_match_;
  bool html_smart_diff_match_;
  bool mismatch_blacklist_threshold_exceeded_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static BlinkInfo* default_instance_;
};
// -------------------------------------------------------------------

class MetadataCacheInfo : public ::google::protobuf::MessageLite {
 public:
  MetadataCacheInfo();
  virtual ~MetadataCacheInfo();
  
  MetadataCacheInfo(const MetadataCacheInfo& from);
  
  inline MetadataCacheInfo& operator=(const MetadataCacheInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const MetadataCacheInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MetadataCacheInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(MetadataCacheInfo* other);
  
  // implements Message ----------------------------------------------
  
  MetadataCacheInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MetadataCacheInfo& from);
  void MergeFrom(const MetadataCacheInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 num_hits = 1;
  inline bool has_num_hits() const;
  inline void clear_num_hits();
  static const int kNumHitsFieldNumber = 1;
  inline ::google::protobuf::int32 num_hits() const;
  inline void set_num_hits(::google::protobuf::int32 value);
  
  // optional int32 num_revalidates = 2;
  inline bool has_num_revalidates() const;
  inline void clear_num_revalidates();
  static const int kNumRevalidatesFieldNumber = 2;
  inline ::google::protobuf::int32 num_revalidates() const;
  inline void set_num_revalidates(::google::protobuf::int32 value);
  
  // optional int32 num_misses = 3;
  inline bool has_num_misses() const;
  inline void clear_num_misses();
  static const int kNumMissesFieldNumber = 3;
  inline ::google::protobuf::int32 num_misses() const;
  inline void set_num_misses(::google::protobuf::int32 value);
  
  // optional int32 num_successful_revalidates = 4;
  inline bool has_num_successful_revalidates() const;
  inline void clear_num_successful_revalidates();
  static const int kNumSuccessfulRevalidatesFieldNumber = 4;
  inline ::google::protobuf::int32 num_successful_revalidates() const;
  inline void set_num_successful_revalidates(::google::protobuf::int32 value);
  
  // optional int32 num_successful_rewrites_on_miss = 5;
  inline bool has_num_successful_rewrites_on_miss() const;
  inline void clear_num_successful_rewrites_on_miss();
  static const int kNumSuccessfulRewritesOnMissFieldNumber = 5;
  inline ::google::protobuf::int32 num_successful_rewrites_on_miss() const;
  inline void set_num_successful_rewrites_on_miss(::google::protobuf::int32 value);
  
  // optional int32 num_stale_rewrites = 6;
  inline bool has_num_stale_rewrites() const;
  inline void clear_num_stale_rewrites();
  static const int kNumStaleRewritesFieldNumber = 6;
  inline ::google::protobuf::int32 num_stale_rewrites() const;
  inline void set_num_stale_rewrites(::google::protobuf::int32 value);
  
  // optional int32 num_rewrites_completed = 7;
  inline bool has_num_rewrites_completed() const;
  inline void clear_num_rewrites_completed();
  static const int kNumRewritesCompletedFieldNumber = 7;
  inline ::google::protobuf::int32 num_rewrites_completed() const;
  inline void set_num_rewrites_completed(::google::protobuf::int32 value);
  
  // optional int32 num_disabled_rewrites = 8;
  inline bool has_num_disabled_rewrites() const;
  inline void clear_num_disabled_rewrites();
  static const int kNumDisabledRewritesFieldNumber = 8;
  inline ::google::protobuf::int32 num_disabled_rewrites() const;
  inline void set_num_disabled_rewrites(::google::protobuf::int32 value);
  
  // optional int32 num_repeated_rewrites = 9;
  inline bool has_num_repeated_rewrites() const;
  inline void clear_num_repeated_rewrites();
  static const int kNumRepeatedRewritesFieldNumber = 9;
  inline ::google::protobuf::int32 num_repeated_rewrites() const;
  inline void set_num_repeated_rewrites(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.MetadataCacheInfo)
 private:
  inline void set_has_num_hits();
  inline void clear_has_num_hits();
  inline void set_has_num_revalidates();
  inline void clear_has_num_revalidates();
  inline void set_has_num_misses();
  inline void clear_has_num_misses();
  inline void set_has_num_successful_revalidates();
  inline void clear_has_num_successful_revalidates();
  inline void set_has_num_successful_rewrites_on_miss();
  inline void clear_has_num_successful_rewrites_on_miss();
  inline void set_has_num_stale_rewrites();
  inline void clear_has_num_stale_rewrites();
  inline void set_has_num_rewrites_completed();
  inline void clear_has_num_rewrites_completed();
  inline void set_has_num_disabled_rewrites();
  inline void clear_has_num_disabled_rewrites();
  inline void set_has_num_repeated_rewrites();
  inline void clear_has_num_repeated_rewrites();
  
  ::google::protobuf::int32 num_hits_;
  ::google::protobuf::int32 num_revalidates_;
  ::google::protobuf::int32 num_misses_;
  ::google::protobuf::int32 num_successful_revalidates_;
  ::google::protobuf::int32 num_successful_rewrites_on_miss_;
  ::google::protobuf::int32 num_stale_rewrites_;
  ::google::protobuf::int32 num_rewrites_completed_;
  ::google::protobuf::int32 num_disabled_rewrites_;
  ::google::protobuf::int32 num_repeated_rewrites_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static MetadataCacheInfo* default_instance_;
};
// -------------------------------------------------------------------

class RewritingInfo : public ::google::protobuf::MessageLite {
 public:
  RewritingInfo();
  virtual ~RewritingInfo();
  
  RewritingInfo(const RewritingInfo& from);
  
  inline RewritingInfo& operator=(const RewritingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RewritingInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewritingInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(RewritingInfo* other);
  
  // implements Message ----------------------------------------------
  
  RewritingInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewritingInfo& from);
  void MergeFrom(const RewritingInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:net_instaweb.RewritingInfo)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static RewritingInfo* default_instance_;
};
// -------------------------------------------------------------------

class SplitHtmlInfo : public ::google::protobuf::MessageLite {
 public:
  SplitHtmlInfo();
  virtual ~SplitHtmlInfo();
  
  SplitHtmlInfo(const SplitHtmlInfo& from);
  
  inline SplitHtmlInfo& operator=(const SplitHtmlInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SplitHtmlInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SplitHtmlInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(SplitHtmlInfo* other);
  
  // implements Message ----------------------------------------------
  
  SplitHtmlInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SplitHtmlInfo& from);
  void MergeFrom(const SplitHtmlInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 json_size = 1;
  inline bool has_json_size() const;
  inline void clear_json_size();
  static const int kJsonSizeFieldNumber = 1;
  inline ::google::protobuf::int64 json_size() const;
  inline void set_json_size(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.SplitHtmlInfo)
 private:
  inline void set_has_json_size();
  inline void clear_has_json_size();
  
  ::google::protobuf::int64 json_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static SplitHtmlInfo* default_instance_;
};
// -------------------------------------------------------------------

class PropertyCohortInfo : public ::google::protobuf::MessageLite {
 public:
  PropertyCohortInfo();
  virtual ~PropertyCohortInfo();
  
  PropertyCohortInfo(const PropertyCohortInfo& from);
  
  inline PropertyCohortInfo& operator=(const PropertyCohortInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PropertyCohortInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PropertyCohortInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(PropertyCohortInfo* other);
  
  // implements Message ----------------------------------------------
  
  PropertyCohortInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PropertyCohortInfo& from);
  void MergeFrom(const PropertyCohortInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional bool is_cache_hit = 2 [default = false];
  inline bool has_is_cache_hit() const;
  inline void clear_is_cache_hit();
  static const int kIsCacheHitFieldNumber = 2;
  inline bool is_cache_hit() const;
  inline void set_is_cache_hit(bool value);
  
  // repeated string properties_found = 3;
  inline int properties_found_size() const;
  inline void clear_properties_found();
  static const int kPropertiesFoundFieldNumber = 3;
  inline const ::std::string& properties_found(int index) const;
  inline ::std::string* mutable_properties_found(int index);
  inline void set_properties_found(int index, const ::std::string& value);
  inline void set_properties_found(int index, const char* value);
  inline void set_properties_found(int index, const char* value, size_t size);
  inline ::std::string* add_properties_found();
  inline void add_properties_found(const ::std::string& value);
  inline void add_properties_found(const char* value);
  inline void add_properties_found(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& properties_found() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_properties_found();
  
  // optional int32 device_type = 4;
  inline bool has_device_type() const;
  inline void clear_device_type();
  static const int kDeviceTypeFieldNumber = 4;
  inline ::google::protobuf::int32 device_type() const;
  inline void set_device_type(::google::protobuf::int32 value);
  
  // optional int32 cache_type = 5;
  inline bool has_cache_type() const;
  inline void clear_cache_type();
  static const int kCacheTypeFieldNumber = 5;
  inline ::google::protobuf::int32 cache_type() const;
  inline void set_cache_type(::google::protobuf::int32 value);
  
  // optional int32 cache_key_state = 6;
  inline bool has_cache_key_state() const;
  inline void clear_cache_key_state();
  static const int kCacheKeyStateFieldNumber = 6;
  inline ::google::protobuf::int32 cache_key_state() const;
  inline void set_cache_key_state(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.PropertyCohortInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_is_cache_hit();
  inline void clear_has_is_cache_hit();
  inline void set_has_device_type();
  inline void clear_has_device_type();
  inline void set_has_cache_type();
  inline void clear_has_cache_type();
  inline void set_has_cache_key_state();
  inline void clear_has_cache_key_state();
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> properties_found_;
  bool is_cache_hit_;
  ::google::protobuf::int32 device_type_;
  ::google::protobuf::int32 cache_type_;
  ::google::protobuf::int32 cache_key_state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static PropertyCohortInfo* default_instance_;
};
// -------------------------------------------------------------------

class PropertyPageInfo : public ::google::protobuf::MessageLite {
 public:
  PropertyPageInfo();
  virtual ~PropertyPageInfo();
  
  PropertyPageInfo(const PropertyPageInfo& from);
  
  inline PropertyPageInfo& operator=(const PropertyPageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PropertyPageInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PropertyPageInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(PropertyPageInfo* other);
  
  // implements Message ----------------------------------------------
  
  PropertyPageInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PropertyPageInfo& from);
  void MergeFrom(const PropertyPageInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .net_instaweb.PropertyCohortInfo cohort_info = 1;
  inline int cohort_info_size() const;
  inline void clear_cohort_info();
  static const int kCohortInfoFieldNumber = 1;
  inline const ::net_instaweb::PropertyCohortInfo& cohort_info(int index) const;
  inline ::net_instaweb::PropertyCohortInfo* mutable_cohort_info(int index);
  inline ::net_instaweb::PropertyCohortInfo* add_cohort_info();
  inline const ::google::protobuf::RepeatedPtrField< ::net_instaweb::PropertyCohortInfo >&
      cohort_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::net_instaweb::PropertyCohortInfo >*
      mutable_cohort_info();
  
  // @@protoc_insertion_point(class_scope:net_instaweb.PropertyPageInfo)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::net_instaweb::PropertyCohortInfo > cohort_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static PropertyPageInfo* default_instance_;
};
// -------------------------------------------------------------------

class FlushEarlyFlowInfo : public ::google::protobuf::MessageLite {
 public:
  FlushEarlyFlowInfo();
  virtual ~FlushEarlyFlowInfo();
  
  FlushEarlyFlowInfo(const FlushEarlyFlowInfo& from);
  
  inline FlushEarlyFlowInfo& operator=(const FlushEarlyFlowInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FlushEarlyFlowInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FlushEarlyFlowInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(FlushEarlyFlowInfo* other);
  
  // implements Message ----------------------------------------------
  
  FlushEarlyFlowInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FlushEarlyFlowInfo& from);
  void MergeFrom(const FlushEarlyFlowInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 available_time_ms = 1;
  inline bool has_available_time_ms() const;
  inline void clear_available_time_ms();
  static const int kAvailableTimeMsFieldNumber = 1;
  inline ::google::protobuf::int64 available_time_ms() const;
  inline void set_available_time_ms(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.FlushEarlyFlowInfo)
 private:
  inline void set_has_available_time_ms();
  inline void clear_has_available_time_ms();
  
  ::google::protobuf::int64 available_time_ms_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static FlushEarlyFlowInfo* default_instance_;
};
// -------------------------------------------------------------------

class FlushEarlyResourceInfo : public ::google::protobuf::MessageLite {
 public:
  FlushEarlyResourceInfo();
  virtual ~FlushEarlyResourceInfo();
  
  FlushEarlyResourceInfo(const FlushEarlyResourceInfo& from);
  
  inline FlushEarlyResourceInfo& operator=(const FlushEarlyResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FlushEarlyResourceInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FlushEarlyResourceInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(FlushEarlyResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  FlushEarlyResourceInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FlushEarlyResourceInfo& from);
  void MergeFrom(const FlushEarlyResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef FlushEarlyResourceInfo_ResourceType ResourceType;
  static const ResourceType UNKNOWN_TYPE = FlushEarlyResourceInfo_ResourceType_UNKNOWN_TYPE;
  static const ResourceType PAGESPEED = FlushEarlyResourceInfo_ResourceType_PAGESPEED;
  static const ResourceType NON_PAGESPEED = FlushEarlyResourceInfo_ResourceType_NON_PAGESPEED;
  static const ResourceType PRIVATE_CACHEABLE = FlushEarlyResourceInfo_ResourceType_PRIVATE_CACHEABLE;
  static const ResourceType DEFERJS_SCRIPT = FlushEarlyResourceInfo_ResourceType_DEFERJS_SCRIPT;
  static inline bool ResourceType_IsValid(int value) {
    return FlushEarlyResourceInfo_ResourceType_IsValid(value);
  }
  static const ResourceType ResourceType_MIN =
    FlushEarlyResourceInfo_ResourceType_ResourceType_MIN;
  static const ResourceType ResourceType_MAX =
    FlushEarlyResourceInfo_ResourceType_ResourceType_MAX;
  static const int ResourceType_ARRAYSIZE =
    FlushEarlyResourceInfo_ResourceType_ResourceType_ARRAYSIZE;
  
  typedef FlushEarlyResourceInfo_ContentType ContentType;
  static const ContentType UNKNOWN_CONTENT_TYPE = FlushEarlyResourceInfo_ContentType_UNKNOWN_CONTENT_TYPE;
  static const ContentType IMAGE = FlushEarlyResourceInfo_ContentType_IMAGE;
  static const ContentType JS = FlushEarlyResourceInfo_ContentType_JS;
  static const ContentType CSS = FlushEarlyResourceInfo_ContentType_CSS;
  static inline bool ContentType_IsValid(int value) {
    return FlushEarlyResourceInfo_ContentType_IsValid(value);
  }
  static const ContentType ContentType_MIN =
    FlushEarlyResourceInfo_ContentType_ContentType_MIN;
  static const ContentType ContentType_MAX =
    FlushEarlyResourceInfo_ContentType_ContentType_MAX;
  static const int ContentType_ARRAYSIZE =
    FlushEarlyResourceInfo_ContentType_ContentType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional .net_instaweb.FlushEarlyResourceInfo.ContentType content_type = 1;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 1;
  inline ::net_instaweb::FlushEarlyResourceInfo_ContentType content_type() const;
  inline void set_content_type(::net_instaweb::FlushEarlyResourceInfo_ContentType value);
  
  // optional .net_instaweb.FlushEarlyResourceInfo.ResourceType resource_type = 2;
  inline bool has_resource_type() const;
  inline void clear_resource_type();
  static const int kResourceTypeFieldNumber = 2;
  inline ::net_instaweb::FlushEarlyResourceInfo_ResourceType resource_type() const;
  inline void set_resource_type(::net_instaweb::FlushEarlyResourceInfo_ResourceType value);
  
  // optional bool is_bandwidth_affected = 3;
  inline bool has_is_bandwidth_affected() const;
  inline void clear_is_bandwidth_affected();
  static const int kIsBandwidthAffectedFieldNumber = 3;
  inline bool is_bandwidth_affected() const;
  inline void set_is_bandwidth_affected(bool value);
  
  // optional bool in_head = 4;
  inline bool has_in_head() const;
  inline void clear_in_head();
  static const int kInHeadFieldNumber = 4;
  inline bool in_head() const;
  inline void set_in_head(bool value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.FlushEarlyResourceInfo)
 private:
  inline void set_has_content_type();
  inline void clear_has_content_type();
  inline void set_has_resource_type();
  inline void clear_has_resource_type();
  inline void set_has_is_bandwidth_affected();
  inline void clear_has_is_bandwidth_affected();
  inline void set_has_in_head();
  inline void clear_has_in_head();
  
  int content_type_;
  int resource_type_;
  bool is_bandwidth_affected_;
  bool in_head_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static FlushEarlyResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class CriticalCssInfo : public ::google::protobuf::MessageLite {
 public:
  CriticalCssInfo();
  virtual ~CriticalCssInfo();
  
  CriticalCssInfo(const CriticalCssInfo& from);
  
  inline CriticalCssInfo& operator=(const CriticalCssInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CriticalCssInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CriticalCssInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(CriticalCssInfo* other);
  
  // implements Message ----------------------------------------------
  
  CriticalCssInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CriticalCssInfo& from);
  void MergeFrom(const CriticalCssInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 critical_inlined_bytes = 1;
  inline bool has_critical_inlined_bytes() const;
  inline void clear_critical_inlined_bytes();
  static const int kCriticalInlinedBytesFieldNumber = 1;
  inline ::google::protobuf::int64 critical_inlined_bytes() const;
  inline void set_critical_inlined_bytes(::google::protobuf::int64 value);
  
  // optional int64 original_external_bytes = 2;
  inline bool has_original_external_bytes() const;
  inline void clear_original_external_bytes();
  static const int kOriginalExternalBytesFieldNumber = 2;
  inline ::google::protobuf::int64 original_external_bytes() const;
  inline void set_original_external_bytes(::google::protobuf::int64 value);
  
  // optional int64 overhead_bytes = 3;
  inline bool has_overhead_bytes() const;
  inline void clear_overhead_bytes();
  static const int kOverheadBytesFieldNumber = 3;
  inline ::google::protobuf::int64 overhead_bytes() const;
  inline void set_overhead_bytes(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.CriticalCssInfo)
 private:
  inline void set_has_critical_inlined_bytes();
  inline void clear_has_critical_inlined_bytes();
  inline void set_has_original_external_bytes();
  inline void clear_has_original_external_bytes();
  inline void set_has_overhead_bytes();
  inline void clear_has_overhead_bytes();
  
  ::google::protobuf::int64 critical_inlined_bytes_;
  ::google::protobuf::int64 original_external_bytes_;
  ::google::protobuf::int64 overhead_bytes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static CriticalCssInfo* default_instance_;
};
// -------------------------------------------------------------------

class CacheHtmlLoggingInfo : public ::google::protobuf::MessageLite {
 public:
  CacheHtmlLoggingInfo();
  virtual ~CacheHtmlLoggingInfo();
  
  CacheHtmlLoggingInfo(const CacheHtmlLoggingInfo& from);
  
  inline CacheHtmlLoggingInfo& operator=(const CacheHtmlLoggingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CacheHtmlLoggingInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CacheHtmlLoggingInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(CacheHtmlLoggingInfo* other);
  
  // implements Message ----------------------------------------------
  
  CacheHtmlLoggingInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CacheHtmlLoggingInfo& from);
  void MergeFrom(const CacheHtmlLoggingInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef CacheHtmlLoggingInfo_CacheHtmlRequestFlow CacheHtmlRequestFlow;
  static const CacheHtmlRequestFlow CACHE_HTML_HIT = CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CACHE_HTML_HIT;
  static const CacheHtmlRequestFlow CACHE_HTML_MISS_FOUND_RESOURCE = CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CACHE_HTML_MISS_FOUND_RESOURCE;
  static const CacheHtmlRequestFlow CACHE_HTML_MISS_FETCH_NON_OK = CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CACHE_HTML_MISS_FETCH_NON_OK;
  static const CacheHtmlRequestFlow CACHE_HTML_MISS_TRIGGERED_REWRITE = CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CACHE_HTML_MISS_TRIGGERED_REWRITE;
  static const CacheHtmlRequestFlow FOUND_MALFORMED_HTML = CacheHtmlLoggingInfo_CacheHtmlRequestFlow_FOUND_MALFORMED_HTML;
  static const CacheHtmlRequestFlow FOUND_CONTENT_LENGTH_OVER_THRESHOLD = CacheHtmlLoggingInfo_CacheHtmlRequestFlow_FOUND_CONTENT_LENGTH_OVER_THRESHOLD;
  static inline bool CacheHtmlRequestFlow_IsValid(int value) {
    return CacheHtmlLoggingInfo_CacheHtmlRequestFlow_IsValid(value);
  }
  static const CacheHtmlRequestFlow CacheHtmlRequestFlow_MIN =
    CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CacheHtmlRequestFlow_MIN;
  static const CacheHtmlRequestFlow CacheHtmlRequestFlow_MAX =
    CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CacheHtmlRequestFlow_MAX;
  static const int CacheHtmlRequestFlow_ARRAYSIZE =
    CacheHtmlLoggingInfo_CacheHtmlRequestFlow_CacheHtmlRequestFlow_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional .net_instaweb.CacheHtmlLoggingInfo.CacheHtmlRequestFlow cache_html_request_flow = 1;
  inline bool has_cache_html_request_flow() const;
  inline void clear_cache_html_request_flow();
  static const int kCacheHtmlRequestFlowFieldNumber = 1;
  inline ::net_instaweb::CacheHtmlLoggingInfo_CacheHtmlRequestFlow cache_html_request_flow() const;
  inline void set_cache_html_request_flow(::net_instaweb::CacheHtmlLoggingInfo_CacheHtmlRequestFlow value);
  
  // optional string request_event_id_time_usec = 2;
  inline bool has_request_event_id_time_usec() const;
  inline void clear_request_event_id_time_usec();
  static const int kRequestEventIdTimeUsecFieldNumber = 2;
  inline const ::std::string& request_event_id_time_usec() const;
  inline void set_request_event_id_time_usec(const ::std::string& value);
  inline void set_request_event_id_time_usec(const char* value);
  inline void set_request_event_id_time_usec(const char* value, size_t size);
  inline ::std::string* mutable_request_event_id_time_usec();
  inline ::std::string* release_request_event_id_time_usec();
  
  // optional bool html_match = 3;
  inline bool has_html_match() const;
  inline void clear_html_match();
  static const int kHtmlMatchFieldNumber = 3;
  inline bool html_match() const;
  inline void set_html_match(bool value);
  
  // optional bool html_smart_diff_match = 4;
  inline bool has_html_smart_diff_match() const;
  inline void clear_html_smart_diff_match();
  static const int kHtmlSmartDiffMatchFieldNumber = 4;
  inline bool html_smart_diff_match() const;
  inline void set_html_smart_diff_match(bool value);
  
  // optional string url = 5;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 5;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // @@protoc_insertion_point(class_scope:net_instaweb.CacheHtmlLoggingInfo)
 private:
  inline void set_has_cache_html_request_flow();
  inline void clear_has_cache_html_request_flow();
  inline void set_has_request_event_id_time_usec();
  inline void clear_has_request_event_id_time_usec();
  inline void set_has_html_match();
  inline void clear_has_html_match();
  inline void set_has_html_smart_diff_match();
  inline void clear_has_html_smart_diff_match();
  inline void set_has_url();
  inline void clear_has_url();
  
  ::std::string* request_event_id_time_usec_;
  int cache_html_request_flow_;
  bool html_match_;
  bool html_smart_diff_match_;
  ::std::string* url_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static CacheHtmlLoggingInfo* default_instance_;
};
// -------------------------------------------------------------------

class RewriteResourceInfo : public ::google::protobuf::MessageLite {
 public:
  RewriteResourceInfo();
  virtual ~RewriteResourceInfo();
  
  RewriteResourceInfo(const RewriteResourceInfo& from);
  
  inline RewriteResourceInfo& operator=(const RewriteResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RewriteResourceInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewriteResourceInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(RewriteResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  RewriteResourceInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewriteResourceInfo& from);
  void MergeFrom(const RewriteResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool is_inlined = 1 [default = false];
  inline bool has_is_inlined() const;
  inline void clear_is_inlined();
  static const int kIsInlinedFieldNumber = 1;
  inline bool is_inlined() const;
  inline void set_is_inlined(bool value);
  
  // optional bool is_critical = 2 [default = false];
  inline bool has_is_critical() const;
  inline void clear_is_critical();
  static const int kIsCriticalFieldNumber = 2;
  inline bool is_critical() const;
  inline void set_is_critical(bool value);
  
  // optional bool has_pagespeed_no_defer = 3 [default = false];
  inline bool has_has_pagespeed_no_defer() const;
  inline void clear_has_pagespeed_no_defer();
  static const int kHasPagespeedNoDeferFieldNumber = 3;
  inline bool has_pagespeed_no_defer() const;
  inline void set_has_pagespeed_no_defer(bool value);
  
  // optional bool is_blacklisted = 4 [default = false];
  inline bool has_is_blacklisted() const;
  inline void clear_is_blacklisted();
  static const int kIsBlacklistedFieldNumber = 4;
  inline bool is_blacklisted() const;
  inline void set_is_blacklisted(bool value);
  
  // optional int32 original_resource_url_index = 5 [default = -1];
  inline bool has_original_resource_url_index() const;
  inline void clear_original_resource_url_index();
  static const int kOriginalResourceUrlIndexFieldNumber = 5;
  inline ::google::protobuf::int32 original_resource_url_index() const;
  inline void set_original_resource_url_index(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.RewriteResourceInfo)
 private:
  inline void set_has_is_inlined();
  inline void clear_has_is_inlined();
  inline void set_has_is_critical();
  inline void clear_has_is_critical();
  inline void set_has_has_pagespeed_no_defer();
  inline void clear_has_has_pagespeed_no_defer();
  inline void set_has_is_blacklisted();
  inline void clear_has_is_blacklisted();
  inline void set_has_original_resource_url_index();
  inline void clear_has_original_resource_url_index();
  
  bool is_inlined_;
  bool is_critical_;
  bool has_pagespeed_no_defer_;
  bool is_blacklisted_;
  ::google::protobuf::int32 original_resource_url_index_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static RewriteResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class ImageRewriteResourceInfo : public ::google::protobuf::MessageLite {
 public:
  ImageRewriteResourceInfo();
  virtual ~ImageRewriteResourceInfo();
  
  ImageRewriteResourceInfo(const ImageRewriteResourceInfo& from);
  
  inline ImageRewriteResourceInfo& operator=(const ImageRewriteResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ImageRewriteResourceInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ImageRewriteResourceInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(ImageRewriteResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  ImageRewriteResourceInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ImageRewriteResourceInfo& from);
  void MergeFrom(const ImageRewriteResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool is_low_res_src_inserted = 1 [default = false];
  inline bool has_is_low_res_src_inserted() const;
  inline void clear_is_low_res_src_inserted();
  static const int kIsLowResSrcInsertedFieldNumber = 1;
  inline bool is_low_res_src_inserted() const;
  inline void set_is_low_res_src_inserted(bool value);
  
  // optional int32 low_res_size = 2 [default = 0];
  inline bool has_low_res_size() const;
  inline void clear_low_res_size();
  static const int kLowResSizeFieldNumber = 2;
  inline ::google::protobuf::int32 low_res_size() const;
  inline void set_low_res_size(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.ImageRewriteResourceInfo)
 private:
  inline void set_has_is_low_res_src_inserted();
  inline void clear_has_is_low_res_src_inserted();
  inline void set_has_low_res_size();
  inline void clear_has_low_res_size();
  
  bool is_low_res_src_inserted_;
  ::google::protobuf::int32 low_res_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static ImageRewriteResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class RewriterInfo : public ::google::protobuf::MessageLite {
 public:
  RewriterInfo();
  virtual ~RewriterInfo();
  
  RewriterInfo(const RewriterInfo& from);
  
  inline RewriterInfo& operator=(const RewriterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RewriterInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewriterInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(RewriterInfo* other);
  
  // implements Message ----------------------------------------------
  
  RewriterInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewriterInfo& from);
  void MergeFrom(const RewriterInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef RewriterInfo_RewriterApplicationStatus RewriterApplicationStatus;
  static const RewriterApplicationStatus UNKNOWN_STATUS = RewriterInfo_RewriterApplicationStatus_UNKNOWN_STATUS;
  static const RewriterApplicationStatus APPLIED_OK = RewriterInfo_RewriterApplicationStatus_APPLIED_OK;
  static const RewriterApplicationStatus NOT_APPLIED = RewriterInfo_RewriterApplicationStatus_NOT_APPLIED;
  static const RewriterApplicationStatus PROPERTY_NOT_FOUND = RewriterInfo_RewriterApplicationStatus_PROPERTY_NOT_FOUND;
  static const RewriterApplicationStatus INPUT_URL_INVALID = RewriterInfo_RewriterApplicationStatus_INPUT_URL_INVALID;
  static const RewriterApplicationStatus REPLACE_FAILED = RewriterInfo_RewriterApplicationStatus_REPLACE_FAILED;
  static inline bool RewriterApplicationStatus_IsValid(int value) {
    return RewriterInfo_RewriterApplicationStatus_IsValid(value);
  }
  static const RewriterApplicationStatus RewriterApplicationStatus_MIN =
    RewriterInfo_RewriterApplicationStatus_RewriterApplicationStatus_MIN;
  static const RewriterApplicationStatus RewriterApplicationStatus_MAX =
    RewriterInfo_RewriterApplicationStatus_RewriterApplicationStatus_MAX;
  static const int RewriterApplicationStatus_ARRAYSIZE =
    RewriterInfo_RewriterApplicationStatus_RewriterApplicationStatus_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // optional .net_instaweb.RewriterInfo.RewriterApplicationStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::net_instaweb::RewriterInfo_RewriterApplicationStatus status() const;
  inline void set_status(::net_instaweb::RewriterInfo_RewriterApplicationStatus value);
  
  // optional .net_instaweb.FlushEarlyResourceInfo flush_early_resource_info = 3;
  inline bool has_flush_early_resource_info() const;
  inline void clear_flush_early_resource_info();
  static const int kFlushEarlyResourceInfoFieldNumber = 3;
  inline const ::net_instaweb::FlushEarlyResourceInfo& flush_early_resource_info() const;
  inline ::net_instaweb::FlushEarlyResourceInfo* mutable_flush_early_resource_info();
  inline ::net_instaweb::FlushEarlyResourceInfo* release_flush_early_resource_info();
  
  // optional .net_instaweb.RewriteResourceInfo rewrite_resource_info = 4;
  inline bool has_rewrite_resource_info() const;
  inline void clear_rewrite_resource_info();
  static const int kRewriteResourceInfoFieldNumber = 4;
  inline const ::net_instaweb::RewriteResourceInfo& rewrite_resource_info() const;
  inline ::net_instaweb::RewriteResourceInfo* mutable_rewrite_resource_info();
  inline ::net_instaweb::RewriteResourceInfo* release_rewrite_resource_info();
  
  // optional .net_instaweb.ImageRewriteResourceInfo image_rewrite_resource_info = 5;
  inline bool has_image_rewrite_resource_info() const;
  inline void clear_image_rewrite_resource_info();
  static const int kImageRewriteResourceInfoFieldNumber = 5;
  inline const ::net_instaweb::ImageRewriteResourceInfo& image_rewrite_resource_info() const;
  inline ::net_instaweb::ImageRewriteResourceInfo* mutable_image_rewrite_resource_info();
  inline ::net_instaweb::ImageRewriteResourceInfo* release_image_rewrite_resource_info();
  
  // @@protoc_insertion_point(class_scope:net_instaweb.RewriterInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_flush_early_resource_info();
  inline void clear_has_flush_early_resource_info();
  inline void set_has_rewrite_resource_info();
  inline void clear_has_rewrite_resource_info();
  inline void set_has_image_rewrite_resource_info();
  inline void clear_has_image_rewrite_resource_info();
  
  ::std::string* id_;
  ::net_instaweb::FlushEarlyResourceInfo* flush_early_resource_info_;
  ::net_instaweb::RewriteResourceInfo* rewrite_resource_info_;
  ::net_instaweb::ImageRewriteResourceInfo* image_rewrite_resource_info_;
  int status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static RewriterInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResourceUrlInfo : public ::google::protobuf::MessageLite {
 public:
  ResourceUrlInfo();
  virtual ~ResourceUrlInfo();
  
  ResourceUrlInfo(const ResourceUrlInfo& from);
  
  inline ResourceUrlInfo& operator=(const ResourceUrlInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ResourceUrlInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResourceUrlInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(ResourceUrlInfo* other);
  
  // implements Message ----------------------------------------------
  
  ResourceUrlInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResourceUrlInfo& from);
  void MergeFrom(const ResourceUrlInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string url = 1;
  inline int url_size() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url(int index) const;
  inline ::std::string* mutable_url(int index);
  inline void set_url(int index, const ::std::string& value);
  inline void set_url(int index, const char* value);
  inline void set_url(int index, const char* value, size_t size);
  inline ::std::string* add_url();
  inline void add_url(const ::std::string& value);
  inline void add_url(const char* value);
  inline void add_url(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& url() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_url();
  
  // @@protoc_insertion_point(class_scope:net_instaweb.ResourceUrlInfo)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::std::string> url_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static ResourceUrlInfo* default_instance_;
};
// -------------------------------------------------------------------

class ImageStats : public ::google::protobuf::MessageLite {
 public:
  ImageStats();
  virtual ~ImageStats();
  
  ImageStats(const ImageStats& from);
  
  inline ImageStats& operator=(const ImageStats& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ImageStats& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ImageStats* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(ImageStats* other);
  
  // implements Message ----------------------------------------------
  
  ImageStats* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ImageStats& from);
  void MergeFrom(const ImageStats& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 num_img_tags = 1;
  inline bool has_num_img_tags() const;
  inline void clear_num_img_tags();
  static const int kNumImgTagsFieldNumber = 1;
  inline ::google::protobuf::int32 num_img_tags() const;
  inline void set_num_img_tags(::google::protobuf::int32 value);
  
  // optional int32 num_inlined_img_tags = 2;
  inline bool has_num_inlined_img_tags() const;
  inline void clear_num_inlined_img_tags();
  static const int kNumInlinedImgTagsFieldNumber = 2;
  inline ::google::protobuf::int32 num_inlined_img_tags() const;
  inline void set_num_inlined_img_tags(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.ImageStats)
 private:
  inline void set_has_num_img_tags();
  inline void clear_has_num_img_tags();
  inline void set_has_num_inlined_img_tags();
  inline void clear_has_num_inlined_img_tags();
  
  ::google::protobuf::int32 num_img_tags_;
  ::google::protobuf::int32 num_inlined_img_tags_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static ImageStats* default_instance_;
};
// -------------------------------------------------------------------

class RewriteStatusCount : public ::google::protobuf::MessageLite {
 public:
  RewriteStatusCount();
  virtual ~RewriteStatusCount();
  
  RewriteStatusCount(const RewriteStatusCount& from);
  
  inline RewriteStatusCount& operator=(const RewriteStatusCount& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RewriteStatusCount& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewriteStatusCount* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(RewriteStatusCount* other);
  
  // implements Message ----------------------------------------------
  
  RewriteStatusCount* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewriteStatusCount& from);
  void MergeFrom(const RewriteStatusCount& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 application_status = 1;
  inline bool has_application_status() const;
  inline void clear_application_status();
  static const int kApplicationStatusFieldNumber = 1;
  inline ::google::protobuf::int32 application_status() const;
  inline void set_application_status(::google::protobuf::int32 value);
  
  // optional int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.RewriteStatusCount)
 private:
  inline void set_has_application_status();
  inline void clear_has_application_status();
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::int32 application_status_;
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static RewriteStatusCount* default_instance_;
};
// -------------------------------------------------------------------

class RewriterStats : public ::google::protobuf::MessageLite {
 public:
  RewriterStats();
  virtual ~RewriterStats();
  
  RewriterStats(const RewriterStats& from);
  
  inline RewriterStats& operator=(const RewriterStats& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RewriterStats& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RewriterStats* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(RewriterStats* other);
  
  // implements Message ----------------------------------------------
  
  RewriterStats* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RewriterStats& from);
  void MergeFrom(const RewriterStats& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef RewriterStats_RewriterHtmlStatus RewriterHtmlStatus;
  static const RewriterHtmlStatus UNKNOWN_STATUS = RewriterStats_RewriterHtmlStatus_UNKNOWN_STATUS;
  static const RewriterHtmlStatus ACTIVE = RewriterStats_RewriterHtmlStatus_ACTIVE;
  static const RewriterHtmlStatus DISABLED = RewriterStats_RewriterHtmlStatus_DISABLED;
  static const RewriterHtmlStatus PROPERTY_CACHE_MISS = RewriterStats_RewriterHtmlStatus_PROPERTY_CACHE_MISS;
  static const RewriterHtmlStatus USER_AGENT_NOT_SUPPORTED = RewriterStats_RewriterHtmlStatus_USER_AGENT_NOT_SUPPORTED;
  static inline bool RewriterHtmlStatus_IsValid(int value) {
    return RewriterStats_RewriterHtmlStatus_IsValid(value);
  }
  static const RewriterHtmlStatus RewriterHtmlStatus_MIN =
    RewriterStats_RewriterHtmlStatus_RewriterHtmlStatus_MIN;
  static const RewriterHtmlStatus RewriterHtmlStatus_MAX =
    RewriterStats_RewriterHtmlStatus_RewriterHtmlStatus_MAX;
  static const int RewriterHtmlStatus_ARRAYSIZE =
    RewriterStats_RewriterHtmlStatus_RewriterHtmlStatus_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // optional .net_instaweb.RewriterStats.RewriterHtmlStatus html_status = 2;
  inline bool has_html_status() const;
  inline void clear_html_status();
  static const int kHtmlStatusFieldNumber = 2;
  inline ::net_instaweb::RewriterStats_RewriterHtmlStatus html_status() const;
  inline void set_html_status(::net_instaweb::RewriterStats_RewriterHtmlStatus value);
  
  // repeated .net_instaweb.RewriteStatusCount status_counts = 3;
  inline int status_counts_size() const;
  inline void clear_status_counts();
  static const int kStatusCountsFieldNumber = 3;
  inline const ::net_instaweb::RewriteStatusCount& status_counts(int index) const;
  inline ::net_instaweb::RewriteStatusCount* mutable_status_counts(int index);
  inline ::net_instaweb::RewriteStatusCount* add_status_counts();
  inline const ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriteStatusCount >&
      status_counts() const;
  inline ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriteStatusCount >*
      mutable_status_counts();
  
  // @@protoc_insertion_point(class_scope:net_instaweb.RewriterStats)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_html_status();
  inline void clear_has_html_status();
  
  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriteStatusCount > status_counts_;
  int html_status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static RewriterStats* default_instance_;
};
// -------------------------------------------------------------------

class DeviceInfo : public ::google::protobuf::MessageLite {
 public:
  DeviceInfo();
  virtual ~DeviceInfo();
  
  DeviceInfo(const DeviceInfo& from);
  
  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const DeviceInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(DeviceInfo* other);
  
  // implements Message ----------------------------------------------
  
  DeviceInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 device_type = 1;
  inline bool has_device_type() const;
  inline void clear_device_type();
  static const int kDeviceTypeFieldNumber = 1;
  inline ::google::protobuf::int32 device_type() const;
  inline void set_device_type(::google::protobuf::int32 value);
  
  // optional bool supports_image_inlining = 2;
  inline bool has_supports_image_inlining() const;
  inline void clear_supports_image_inlining();
  static const int kSupportsImageInliningFieldNumber = 2;
  inline bool supports_image_inlining() const;
  inline void set_supports_image_inlining(bool value);
  
  // optional bool supports_lazyload_images = 3;
  inline bool has_supports_lazyload_images() const;
  inline void clear_supports_lazyload_images();
  static const int kSupportsLazyloadImagesFieldNumber = 3;
  inline bool supports_lazyload_images() const;
  inline void set_supports_lazyload_images(bool value);
  
  // optional bool supports_critical_images_beacon = 4;
  inline bool has_supports_critical_images_beacon() const;
  inline void clear_supports_critical_images_beacon();
  static const int kSupportsCriticalImagesBeaconFieldNumber = 4;
  inline bool supports_critical_images_beacon() const;
  inline void set_supports_critical_images_beacon(bool value);
  
  // optional bool supports_deferjs = 5;
  inline bool has_supports_deferjs() const;
  inline void clear_supports_deferjs();
  static const int kSupportsDeferjsFieldNumber = 5;
  inline bool supports_deferjs() const;
  inline void set_supports_deferjs(bool value);
  
  // optional bool supports_webp = 6;
  inline bool has_supports_webp() const;
  inline void clear_supports_webp();
  static const int kSupportsWebpFieldNumber = 6;
  inline bool supports_webp() const;
  inline void set_supports_webp(bool value);
  
  // optional bool supports_webplossless_alpha = 7;
  inline bool has_supports_webplossless_alpha() const;
  inline void clear_supports_webplossless_alpha();
  static const int kSupportsWebplosslessAlphaFieldNumber = 7;
  inline bool supports_webplossless_alpha() const;
  inline void set_supports_webplossless_alpha(bool value);
  
  // optional bool is_bot = 8;
  inline bool has_is_bot() const;
  inline void clear_is_bot();
  static const int kIsBotFieldNumber = 8;
  inline bool is_bot() const;
  inline void set_is_bot(bool value);
  
  // optional bool supports_split_html = 9;
  inline bool has_supports_split_html() const;
  inline void clear_supports_split_html();
  static const int kSupportsSplitHtmlFieldNumber = 9;
  inline bool supports_split_html() const;
  inline void set_supports_split_html(bool value);
  
  // optional bool can_preload_resources = 10;
  inline bool has_can_preload_resources() const;
  inline void clear_can_preload_resources();
  static const int kCanPreloadResourcesFieldNumber = 10;
  inline bool can_preload_resources() const;
  inline void set_can_preload_resources(bool value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.DeviceInfo)
 private:
  inline void set_has_device_type();
  inline void clear_has_device_type();
  inline void set_has_supports_image_inlining();
  inline void clear_has_supports_image_inlining();
  inline void set_has_supports_lazyload_images();
  inline void clear_has_supports_lazyload_images();
  inline void set_has_supports_critical_images_beacon();
  inline void clear_has_supports_critical_images_beacon();
  inline void set_has_supports_deferjs();
  inline void clear_has_supports_deferjs();
  inline void set_has_supports_webp();
  inline void clear_has_supports_webp();
  inline void set_has_supports_webplossless_alpha();
  inline void clear_has_supports_webplossless_alpha();
  inline void set_has_is_bot();
  inline void clear_has_is_bot();
  inline void set_has_supports_split_html();
  inline void clear_has_supports_split_html();
  inline void set_has_can_preload_resources();
  inline void clear_has_can_preload_resources();
  
  ::google::protobuf::int32 device_type_;
  bool supports_image_inlining_;
  bool supports_lazyload_images_;
  bool supports_critical_images_beacon_;
  bool supports_deferjs_;
  bool supports_webp_;
  bool supports_webplossless_alpha_;
  bool is_bot_;
  bool supports_split_html_;
  bool can_preload_resources_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static DeviceInfo* default_instance_;
};
// -------------------------------------------------------------------

class LoggingInfo : public ::google::protobuf::MessageLite {
 public:
  LoggingInfo();
  virtual ~LoggingInfo();
  
  LoggingInfo(const LoggingInfo& from);
  
  inline LoggingInfo& operator=(const LoggingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const LoggingInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoggingInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(LoggingInfo* other);
  
  // implements Message ----------------------------------------------
  
  LoggingInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoggingInfo& from);
  void MergeFrom(const LoggingInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .net_instaweb.TimingInfo timing_info = 1;
  inline bool has_timing_info() const;
  inline void clear_timing_info();
  static const int kTimingInfoFieldNumber = 1;
  inline const ::net_instaweb::TimingInfo& timing_info() const;
  inline ::net_instaweb::TimingInfo* mutable_timing_info();
  inline ::net_instaweb::TimingInfo* release_timing_info();
  
  // optional .net_instaweb.BlinkInfo blink_info = 2;
  inline bool has_blink_info() const;
  inline void clear_blink_info();
  static const int kBlinkInfoFieldNumber = 2;
  inline const ::net_instaweb::BlinkInfo& blink_info() const;
  inline ::net_instaweb::BlinkInfo* mutable_blink_info();
  inline ::net_instaweb::BlinkInfo* release_blink_info();
  
  // optional string applied_rewriters = 3;
  inline bool has_applied_rewriters() const;
  inline void clear_applied_rewriters();
  static const int kAppliedRewritersFieldNumber = 3;
  inline const ::std::string& applied_rewriters() const;
  inline void set_applied_rewriters(const ::std::string& value);
  inline void set_applied_rewriters(const char* value);
  inline void set_applied_rewriters(const char* value, size_t size);
  inline ::std::string* mutable_applied_rewriters();
  inline ::std::string* release_applied_rewriters();
  
  // optional .net_instaweb.MetadataCacheInfo metadata_cache_info = 4;
  inline bool has_metadata_cache_info() const;
  inline void clear_metadata_cache_info();
  static const int kMetadataCacheInfoFieldNumber = 4;
  inline const ::net_instaweb::MetadataCacheInfo& metadata_cache_info() const;
  inline ::net_instaweb::MetadataCacheInfo* mutable_metadata_cache_info();
  inline ::net_instaweb::MetadataCacheInfo* release_metadata_cache_info();
  
  // optional bool is_original_resource_cacheable = 5 [default = true];
  inline bool has_is_original_resource_cacheable() const;
  inline void clear_is_original_resource_cacheable();
  static const int kIsOriginalResourceCacheableFieldNumber = 5;
  inline bool is_original_resource_cacheable() const;
  inline void set_is_original_resource_cacheable(bool value);
  
  // optional int32 furious_id = 6;
  inline bool has_furious_id() const;
  inline void clear_furious_id();
  static const int kFuriousIdFieldNumber = 6;
  inline ::google::protobuf::int32 furious_id() const;
  inline void set_furious_id(::google::protobuf::int32 value);
  
  // optional .net_instaweb.SplitHtmlInfo split_html_info = 7;
  inline bool has_split_html_info() const;
  inline void clear_split_html_info();
  static const int kSplitHtmlInfoFieldNumber = 7;
  inline const ::net_instaweb::SplitHtmlInfo& split_html_info() const;
  inline ::net_instaweb::SplitHtmlInfo* mutable_split_html_info();
  inline ::net_instaweb::SplitHtmlInfo* release_split_html_info();
  
  // optional .net_instaweb.PropertyPageInfo property_page_info = 8;
  inline bool has_property_page_info() const;
  inline void clear_property_page_info();
  static const int kPropertyPageInfoFieldNumber = 8;
  inline const ::net_instaweb::PropertyPageInfo& property_page_info() const;
  inline ::net_instaweb::PropertyPageInfo* mutable_property_page_info();
  inline ::net_instaweb::PropertyPageInfo* release_property_page_info();
  
  // repeated .net_instaweb.RewriterInfo rewriter_info = 9;
  inline int rewriter_info_size() const;
  inline void clear_rewriter_info();
  static const int kRewriterInfoFieldNumber = 9;
  inline const ::net_instaweb::RewriterInfo& rewriter_info(int index) const;
  inline ::net_instaweb::RewriterInfo* mutable_rewriter_info(int index);
  inline ::net_instaweb::RewriterInfo* add_rewriter_info();
  inline const ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriterInfo >&
      rewriter_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriterInfo >*
      mutable_rewriter_info();
  
  // repeated .net_instaweb.RewriterStats rewriter_stats = 22;
  inline int rewriter_stats_size() const;
  inline void clear_rewriter_stats();
  static const int kRewriterStatsFieldNumber = 22;
  inline const ::net_instaweb::RewriterStats& rewriter_stats(int index) const;
  inline ::net_instaweb::RewriterStats* mutable_rewriter_stats(int index);
  inline ::net_instaweb::RewriterStats* add_rewriter_stats();
  inline const ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriterStats >&
      rewriter_stats() const;
  inline ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriterStats >*
      mutable_rewriter_stats();
  
  // optional bool is_html_response = 10 [default = false];
  inline bool has_is_html_response() const;
  inline void clear_is_html_response();
  static const int kIsHtmlResponseFieldNumber = 10;
  inline bool is_html_response() const;
  inline void set_is_html_response(bool value);
  
  // optional bool is_url_disallowed = 11 [default = false];
  inline bool has_is_url_disallowed() const;
  inline void clear_is_url_disallowed();
  static const int kIsUrlDisallowedFieldNumber = 11;
  inline bool is_url_disallowed() const;
  inline void set_is_url_disallowed(bool value);
  
  // optional int64 options_signature_hash = 12;
  inline bool has_options_signature_hash() const;
  inline void clear_options_signature_hash();
  static const int kOptionsSignatureHashFieldNumber = 12;
  inline ::google::protobuf::int64 options_signature_hash() const;
  inline void set_options_signature_hash(::google::protobuf::int64 value);
  
  // optional bool is_request_disabled = 13 [default = false];
  inline bool has_is_request_disabled() const;
  inline void clear_is_request_disabled();
  static const int kIsRequestDisabledFieldNumber = 13;
  inline bool is_request_disabled() const;
  inline void set_is_request_disabled(bool value);
  
  // optional .net_instaweb.FlushEarlyFlowInfo flush_early_flow_info = 14;
  inline bool has_flush_early_flow_info() const;
  inline void clear_flush_early_flow_info();
  static const int kFlushEarlyFlowInfoFieldNumber = 14;
  inline const ::net_instaweb::FlushEarlyFlowInfo& flush_early_flow_info() const;
  inline ::net_instaweb::FlushEarlyFlowInfo* mutable_flush_early_flow_info();
  inline ::net_instaweb::FlushEarlyFlowInfo* release_flush_early_flow_info();
  
  // optional bool rewriter_info_size_limit_exceeded = 15 [default = false];
  inline bool has_rewriter_info_size_limit_exceeded() const;
  inline void clear_rewriter_info_size_limit_exceeded();
  static const int kRewriterInfoSizeLimitExceededFieldNumber = 15;
  inline bool rewriter_info_size_limit_exceeded() const;
  inline void set_rewriter_info_size_limit_exceeded(bool value);
  
  // optional bool is_pagespeed_resource = 16 [default = false];
  inline bool has_is_pagespeed_resource() const;
  inline void clear_is_pagespeed_resource();
  static const int kIsPagespeedResourceFieldNumber = 16;
  inline bool is_pagespeed_resource() const;
  inline void set_is_pagespeed_resource(bool value);
  
  // optional .net_instaweb.ResourceUrlInfo resource_url_info = 17;
  inline bool has_resource_url_info() const;
  inline void clear_resource_url_info();
  static const int kResourceUrlInfoFieldNumber = 17;
  inline const ::net_instaweb::ResourceUrlInfo& resource_url_info() const;
  inline ::net_instaweb::ResourceUrlInfo* mutable_resource_url_info();
  inline ::net_instaweb::ResourceUrlInfo* release_resource_url_info();
  
  // optional .net_instaweb.CacheHtmlLoggingInfo cache_html_logging_info = 18;
  inline bool has_cache_html_logging_info() const;
  inline void clear_cache_html_logging_info();
  static const int kCacheHtmlLoggingInfoFieldNumber = 18;
  inline const ::net_instaweb::CacheHtmlLoggingInfo& cache_html_logging_info() const;
  inline ::net_instaweb::CacheHtmlLoggingInfo* mutable_cache_html_logging_info();
  inline ::net_instaweb::CacheHtmlLoggingInfo* release_cache_html_logging_info();
  
  // optional int32 num_html_critical_images = 19 [default = -1];
  inline bool has_num_html_critical_images() const;
  inline void clear_num_html_critical_images();
  static const int kNumHtmlCriticalImagesFieldNumber = 19;
  inline ::google::protobuf::int32 num_html_critical_images() const;
  inline void set_num_html_critical_images(::google::protobuf::int32 value);
  
  // optional int32 num_css_critical_images = 20 [default = -1];
  inline bool has_num_css_critical_images() const;
  inline void clear_num_css_critical_images();
  static const int kNumCssCriticalImagesFieldNumber = 20;
  inline ::google::protobuf::int32 num_css_critical_images() const;
  inline void set_num_css_critical_images(::google::protobuf::int32 value);
  
  // optional .net_instaweb.ImageStats image_stats = 21;
  inline bool has_image_stats() const;
  inline void clear_image_stats();
  static const int kImageStatsFieldNumber = 21;
  inline const ::net_instaweb::ImageStats& image_stats() const;
  inline ::net_instaweb::ImageStats* mutable_image_stats();
  inline ::net_instaweb::ImageStats* release_image_stats();
  
  // optional .net_instaweb.CriticalCssInfo critical_css_info = 23;
  inline bool has_critical_css_info() const;
  inline void clear_critical_css_info();
  static const int kCriticalCssInfoFieldNumber = 23;
  inline const ::net_instaweb::CriticalCssInfo& critical_css_info() const;
  inline ::net_instaweb::CriticalCssInfo* mutable_critical_css_info();
  inline ::net_instaweb::CriticalCssInfo* release_critical_css_info();
  
  // optional .net_instaweb.DeviceInfo device_info = 24;
  inline bool has_device_info() const;
  inline void clear_device_info();
  static const int kDeviceInfoFieldNumber = 24;
  inline const ::net_instaweb::DeviceInfo& device_info() const;
  inline ::net_instaweb::DeviceInfo* mutable_device_info();
  inline ::net_instaweb::DeviceInfo* release_device_info();
  
  // @@protoc_insertion_point(class_scope:net_instaweb.LoggingInfo)
 private:
  inline void set_has_timing_info();
  inline void clear_has_timing_info();
  inline void set_has_blink_info();
  inline void clear_has_blink_info();
  inline void set_has_applied_rewriters();
  inline void clear_has_applied_rewriters();
  inline void set_has_metadata_cache_info();
  inline void clear_has_metadata_cache_info();
  inline void set_has_is_original_resource_cacheable();
  inline void clear_has_is_original_resource_cacheable();
  inline void set_has_furious_id();
  inline void clear_has_furious_id();
  inline void set_has_split_html_info();
  inline void clear_has_split_html_info();
  inline void set_has_property_page_info();
  inline void clear_has_property_page_info();
  inline void set_has_is_html_response();
  inline void clear_has_is_html_response();
  inline void set_has_is_url_disallowed();
  inline void clear_has_is_url_disallowed();
  inline void set_has_options_signature_hash();
  inline void clear_has_options_signature_hash();
  inline void set_has_is_request_disabled();
  inline void clear_has_is_request_disabled();
  inline void set_has_flush_early_flow_info();
  inline void clear_has_flush_early_flow_info();
  inline void set_has_rewriter_info_size_limit_exceeded();
  inline void clear_has_rewriter_info_size_limit_exceeded();
  inline void set_has_is_pagespeed_resource();
  inline void clear_has_is_pagespeed_resource();
  inline void set_has_resource_url_info();
  inline void clear_has_resource_url_info();
  inline void set_has_cache_html_logging_info();
  inline void clear_has_cache_html_logging_info();
  inline void set_has_num_html_critical_images();
  inline void clear_has_num_html_critical_images();
  inline void set_has_num_css_critical_images();
  inline void clear_has_num_css_critical_images();
  inline void set_has_image_stats();
  inline void clear_has_image_stats();
  inline void set_has_critical_css_info();
  inline void clear_has_critical_css_info();
  inline void set_has_device_info();
  inline void clear_has_device_info();
  
  ::net_instaweb::TimingInfo* timing_info_;
  ::net_instaweb::BlinkInfo* blink_info_;
  ::std::string* applied_rewriters_;
  ::net_instaweb::MetadataCacheInfo* metadata_cache_info_;
  ::net_instaweb::SplitHtmlInfo* split_html_info_;
  ::net_instaweb::PropertyPageInfo* property_page_info_;
  ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriterInfo > rewriter_info_;
  ::google::protobuf::int32 furious_id_;
  bool is_original_resource_cacheable_;
  bool is_html_response_;
  bool is_url_disallowed_;
  bool is_request_disabled_;
  ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriterStats > rewriter_stats_;
  ::google::protobuf::int64 options_signature_hash_;
  ::net_instaweb::FlushEarlyFlowInfo* flush_early_flow_info_;
  bool rewriter_info_size_limit_exceeded_;
  bool is_pagespeed_resource_;
  ::google::protobuf::int32 num_html_critical_images_;
  ::net_instaweb::ResourceUrlInfo* resource_url_info_;
  ::net_instaweb::CacheHtmlLoggingInfo* cache_html_logging_info_;
  ::net_instaweb::ImageStats* image_stats_;
  ::net_instaweb::CriticalCssInfo* critical_css_info_;
  ::net_instaweb::DeviceInfo* device_info_;
  ::google::protobuf::int32 num_css_critical_images_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(24 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2fhttp_2flogging_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2fhttp_2flogging_2eproto();
  
  void InitAsDefaultInstance();
  static LoggingInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// TimingInfo

// optional int64 cache1_ms = 1;
inline bool TimingInfo::has_cache1_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimingInfo::set_has_cache1_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimingInfo::clear_has_cache1_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimingInfo::clear_cache1_ms() {
  cache1_ms_ = GOOGLE_LONGLONG(0);
  clear_has_cache1_ms();
}
inline ::google::protobuf::int64 TimingInfo::cache1_ms() const {
  return cache1_ms_;
}
inline void TimingInfo::set_cache1_ms(::google::protobuf::int64 value) {
  set_has_cache1_ms();
  cache1_ms_ = value;
}

// optional int64 cache2_ms = 2;
inline bool TimingInfo::has_cache2_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimingInfo::set_has_cache2_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimingInfo::clear_has_cache2_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimingInfo::clear_cache2_ms() {
  cache2_ms_ = GOOGLE_LONGLONG(0);
  clear_has_cache2_ms();
}
inline ::google::protobuf::int64 TimingInfo::cache2_ms() const {
  return cache2_ms_;
}
inline void TimingInfo::set_cache2_ms(::google::protobuf::int64 value) {
  set_has_cache2_ms();
  cache2_ms_ = value;
}

// optional int64 header_fetch_ms = 3;
inline bool TimingInfo::has_header_fetch_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimingInfo::set_has_header_fetch_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimingInfo::clear_has_header_fetch_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimingInfo::clear_header_fetch_ms() {
  header_fetch_ms_ = GOOGLE_LONGLONG(0);
  clear_has_header_fetch_ms();
}
inline ::google::protobuf::int64 TimingInfo::header_fetch_ms() const {
  return header_fetch_ms_;
}
inline void TimingInfo::set_header_fetch_ms(::google::protobuf::int64 value) {
  set_has_header_fetch_ms();
  header_fetch_ms_ = value;
}

// optional int64 fetch_ms = 4;
inline bool TimingInfo::has_fetch_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimingInfo::set_has_fetch_ms() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimingInfo::clear_has_fetch_ms() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimingInfo::clear_fetch_ms() {
  fetch_ms_ = GOOGLE_LONGLONG(0);
  clear_has_fetch_ms();
}
inline ::google::protobuf::int64 TimingInfo::fetch_ms() const {
  return fetch_ms_;
}
inline void TimingInfo::set_fetch_ms(::google::protobuf::int64 value) {
  set_has_fetch_ms();
  fetch_ms_ = value;
}

// optional int64 time_to_first_byte_ms = 5;
inline bool TimingInfo::has_time_to_first_byte_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TimingInfo::set_has_time_to_first_byte_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TimingInfo::clear_has_time_to_first_byte_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TimingInfo::clear_time_to_first_byte_ms() {
  time_to_first_byte_ms_ = GOOGLE_LONGLONG(0);
  clear_has_time_to_first_byte_ms();
}
inline ::google::protobuf::int64 TimingInfo::time_to_first_byte_ms() const {
  return time_to_first_byte_ms_;
}
inline void TimingInfo::set_time_to_first_byte_ms(::google::protobuf::int64 value) {
  set_has_time_to_first_byte_ms();
  time_to_first_byte_ms_ = value;
}

// optional int64 request_start_ms = 6;
inline bool TimingInfo::has_request_start_ms() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TimingInfo::set_has_request_start_ms() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TimingInfo::clear_has_request_start_ms() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TimingInfo::clear_request_start_ms() {
  request_start_ms_ = GOOGLE_LONGLONG(0);
  clear_has_request_start_ms();
}
inline ::google::protobuf::int64 TimingInfo::request_start_ms() const {
  return request_start_ms_;
}
inline void TimingInfo::set_request_start_ms(::google::protobuf::int64 value) {
  set_has_request_start_ms();
  request_start_ms_ = value;
}

// optional int64 time_to_start_parse_ms = 7;
inline bool TimingInfo::has_time_to_start_parse_ms() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TimingInfo::set_has_time_to_start_parse_ms() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TimingInfo::clear_has_time_to_start_parse_ms() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TimingInfo::clear_time_to_start_parse_ms() {
  time_to_start_parse_ms_ = GOOGLE_LONGLONG(0);
  clear_has_time_to_start_parse_ms();
}
inline ::google::protobuf::int64 TimingInfo::time_to_start_parse_ms() const {
  return time_to_start_parse_ms_;
}
inline void TimingInfo::set_time_to_start_parse_ms(::google::protobuf::int64 value) {
  set_has_time_to_start_parse_ms();
  time_to_start_parse_ms_ = value;
}

// optional int64 time_to_start_fetch_ms = 8;
inline bool TimingInfo::has_time_to_start_fetch_ms() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TimingInfo::set_has_time_to_start_fetch_ms() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TimingInfo::clear_has_time_to_start_fetch_ms() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TimingInfo::clear_time_to_start_fetch_ms() {
  time_to_start_fetch_ms_ = GOOGLE_LONGLONG(0);
  clear_has_time_to_start_fetch_ms();
}
inline ::google::protobuf::int64 TimingInfo::time_to_start_fetch_ms() const {
  return time_to_start_fetch_ms_;
}
inline void TimingInfo::set_time_to_start_fetch_ms(::google::protobuf::int64 value) {
  set_has_time_to_start_fetch_ms();
  time_to_start_fetch_ms_ = value;
}

// optional int64 processing_time_ms = 9;
inline bool TimingInfo::has_processing_time_ms() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TimingInfo::set_has_processing_time_ms() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TimingInfo::clear_has_processing_time_ms() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TimingInfo::clear_processing_time_ms() {
  processing_time_ms_ = GOOGLE_LONGLONG(0);
  clear_has_processing_time_ms();
}
inline ::google::protobuf::int64 TimingInfo::processing_time_ms() const {
  return processing_time_ms_;
}
inline void TimingInfo::set_processing_time_ms(::google::protobuf::int64 value) {
  set_has_processing_time_ms();
  processing_time_ms_ = value;
}

// -------------------------------------------------------------------

// BlinkInfo

// optional .net_instaweb.BlinkInfo.BlinkRequestFlow blink_request_flow = 1;
inline bool BlinkInfo::has_blink_request_flow() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlinkInfo::set_has_blink_request_flow() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlinkInfo::clear_has_blink_request_flow() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlinkInfo::clear_blink_request_flow() {
  blink_request_flow_ = 1;
  clear_has_blink_request_flow();
}
inline ::net_instaweb::BlinkInfo_BlinkRequestFlow BlinkInfo::blink_request_flow() const {
  return static_cast< ::net_instaweb::BlinkInfo_BlinkRequestFlow >(blink_request_flow_);
}
inline void BlinkInfo::set_blink_request_flow(::net_instaweb::BlinkInfo_BlinkRequestFlow value) {
  GOOGLE_DCHECK(::net_instaweb::BlinkInfo_BlinkRequestFlow_IsValid(value));
  set_has_blink_request_flow();
  blink_request_flow_ = value;
}

// optional string request_event_id_time_usec = 2;
inline bool BlinkInfo::has_request_event_id_time_usec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlinkInfo::set_has_request_event_id_time_usec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlinkInfo::clear_has_request_event_id_time_usec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlinkInfo::clear_request_event_id_time_usec() {
  if (request_event_id_time_usec_ != &::google::protobuf::internal::kEmptyString) {
    request_event_id_time_usec_->clear();
  }
  clear_has_request_event_id_time_usec();
}
inline const ::std::string& BlinkInfo::request_event_id_time_usec() const {
  return *request_event_id_time_usec_;
}
inline void BlinkInfo::set_request_event_id_time_usec(const ::std::string& value) {
  set_has_request_event_id_time_usec();
  if (request_event_id_time_usec_ == &::google::protobuf::internal::kEmptyString) {
    request_event_id_time_usec_ = new ::std::string;
  }
  request_event_id_time_usec_->assign(value);
}
inline void BlinkInfo::set_request_event_id_time_usec(const char* value) {
  set_has_request_event_id_time_usec();
  if (request_event_id_time_usec_ == &::google::protobuf::internal::kEmptyString) {
    request_event_id_time_usec_ = new ::std::string;
  }
  request_event_id_time_usec_->assign(value);
}
inline void BlinkInfo::set_request_event_id_time_usec(const char* value, size_t size) {
  set_has_request_event_id_time_usec();
  if (request_event_id_time_usec_ == &::google::protobuf::internal::kEmptyString) {
    request_event_id_time_usec_ = new ::std::string;
  }
  request_event_id_time_usec_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlinkInfo::mutable_request_event_id_time_usec() {
  set_has_request_event_id_time_usec();
  if (request_event_id_time_usec_ == &::google::protobuf::internal::kEmptyString) {
    request_event_id_time_usec_ = new ::std::string;
  }
  return request_event_id_time_usec_;
}
inline ::std::string* BlinkInfo::release_request_event_id_time_usec() {
  clear_has_request_event_id_time_usec();
  if (request_event_id_time_usec_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_event_id_time_usec_;
    request_event_id_time_usec_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool html_match = 3;
inline bool BlinkInfo::has_html_match() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlinkInfo::set_has_html_match() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlinkInfo::clear_has_html_match() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlinkInfo::clear_html_match() {
  html_match_ = false;
  clear_has_html_match();
}
inline bool BlinkInfo::html_match() const {
  return html_match_;
}
inline void BlinkInfo::set_html_match(bool value) {
  set_has_html_match();
  html_match_ = value;
}

// optional .net_instaweb.BlinkInfo.UserAgent blink_user_agent = 4;
inline bool BlinkInfo::has_blink_user_agent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlinkInfo::set_has_blink_user_agent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlinkInfo::clear_has_blink_user_agent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlinkInfo::clear_blink_user_agent() {
  blink_user_agent_ = 0;
  clear_has_blink_user_agent();
}
inline ::net_instaweb::BlinkInfo_UserAgent BlinkInfo::blink_user_agent() const {
  return static_cast< ::net_instaweb::BlinkInfo_UserAgent >(blink_user_agent_);
}
inline void BlinkInfo::set_blink_user_agent(::net_instaweb::BlinkInfo_UserAgent value) {
  GOOGLE_DCHECK(::net_instaweb::BlinkInfo_UserAgent_IsValid(value));
  set_has_blink_user_agent();
  blink_user_agent_ = value;
}

// optional string url = 5;
inline bool BlinkInfo::has_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlinkInfo::set_has_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlinkInfo::clear_has_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlinkInfo::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& BlinkInfo::url() const {
  return *url_;
}
inline void BlinkInfo::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void BlinkInfo::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void BlinkInfo::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlinkInfo::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* BlinkInfo::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool html_smart_diff_match = 6;
inline bool BlinkInfo::has_html_smart_diff_match() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlinkInfo::set_has_html_smart_diff_match() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlinkInfo::clear_has_html_smart_diff_match() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlinkInfo::clear_html_smart_diff_match() {
  html_smart_diff_match_ = false;
  clear_has_html_smart_diff_match();
}
inline bool BlinkInfo::html_smart_diff_match() const {
  return html_smart_diff_match_;
}
inline void BlinkInfo::set_html_smart_diff_match(bool value) {
  set_has_html_smart_diff_match();
  html_smart_diff_match_ = value;
}

// optional bool mismatch_blacklist_threshold_exceeded = 7;
inline bool BlinkInfo::has_mismatch_blacklist_threshold_exceeded() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BlinkInfo::set_has_mismatch_blacklist_threshold_exceeded() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BlinkInfo::clear_has_mismatch_blacklist_threshold_exceeded() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BlinkInfo::clear_mismatch_blacklist_threshold_exceeded() {
  mismatch_blacklist_threshold_exceeded_ = false;
  clear_has_mismatch_blacklist_threshold_exceeded();
}
inline bool BlinkInfo::mismatch_blacklist_threshold_exceeded() const {
  return mismatch_blacklist_threshold_exceeded_;
}
inline void BlinkInfo::set_mismatch_blacklist_threshold_exceeded(bool value) {
  set_has_mismatch_blacklist_threshold_exceeded();
  mismatch_blacklist_threshold_exceeded_ = value;
}

// -------------------------------------------------------------------

// MetadataCacheInfo

// optional int32 num_hits = 1;
inline bool MetadataCacheInfo::has_num_hits() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetadataCacheInfo::set_has_num_hits() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetadataCacheInfo::clear_has_num_hits() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetadataCacheInfo::clear_num_hits() {
  num_hits_ = 0;
  clear_has_num_hits();
}
inline ::google::protobuf::int32 MetadataCacheInfo::num_hits() const {
  return num_hits_;
}
inline void MetadataCacheInfo::set_num_hits(::google::protobuf::int32 value) {
  set_has_num_hits();
  num_hits_ = value;
}

// optional int32 num_revalidates = 2;
inline bool MetadataCacheInfo::has_num_revalidates() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetadataCacheInfo::set_has_num_revalidates() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetadataCacheInfo::clear_has_num_revalidates() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetadataCacheInfo::clear_num_revalidates() {
  num_revalidates_ = 0;
  clear_has_num_revalidates();
}
inline ::google::protobuf::int32 MetadataCacheInfo::num_revalidates() const {
  return num_revalidates_;
}
inline void MetadataCacheInfo::set_num_revalidates(::google::protobuf::int32 value) {
  set_has_num_revalidates();
  num_revalidates_ = value;
}

// optional int32 num_misses = 3;
inline bool MetadataCacheInfo::has_num_misses() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetadataCacheInfo::set_has_num_misses() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetadataCacheInfo::clear_has_num_misses() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetadataCacheInfo::clear_num_misses() {
  num_misses_ = 0;
  clear_has_num_misses();
}
inline ::google::protobuf::int32 MetadataCacheInfo::num_misses() const {
  return num_misses_;
}
inline void MetadataCacheInfo::set_num_misses(::google::protobuf::int32 value) {
  set_has_num_misses();
  num_misses_ = value;
}

// optional int32 num_successful_revalidates = 4;
inline bool MetadataCacheInfo::has_num_successful_revalidates() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MetadataCacheInfo::set_has_num_successful_revalidates() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MetadataCacheInfo::clear_has_num_successful_revalidates() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MetadataCacheInfo::clear_num_successful_revalidates() {
  num_successful_revalidates_ = 0;
  clear_has_num_successful_revalidates();
}
inline ::google::protobuf::int32 MetadataCacheInfo::num_successful_revalidates() const {
  return num_successful_revalidates_;
}
inline void MetadataCacheInfo::set_num_successful_revalidates(::google::protobuf::int32 value) {
  set_has_num_successful_revalidates();
  num_successful_revalidates_ = value;
}

// optional int32 num_successful_rewrites_on_miss = 5;
inline bool MetadataCacheInfo::has_num_successful_rewrites_on_miss() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MetadataCacheInfo::set_has_num_successful_rewrites_on_miss() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MetadataCacheInfo::clear_has_num_successful_rewrites_on_miss() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MetadataCacheInfo::clear_num_successful_rewrites_on_miss() {
  num_successful_rewrites_on_miss_ = 0;
  clear_has_num_successful_rewrites_on_miss();
}
inline ::google::protobuf::int32 MetadataCacheInfo::num_successful_rewrites_on_miss() const {
  return num_successful_rewrites_on_miss_;
}
inline void MetadataCacheInfo::set_num_successful_rewrites_on_miss(::google::protobuf::int32 value) {
  set_has_num_successful_rewrites_on_miss();
  num_successful_rewrites_on_miss_ = value;
}

// optional int32 num_stale_rewrites = 6;
inline bool MetadataCacheInfo::has_num_stale_rewrites() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MetadataCacheInfo::set_has_num_stale_rewrites() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MetadataCacheInfo::clear_has_num_stale_rewrites() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MetadataCacheInfo::clear_num_stale_rewrites() {
  num_stale_rewrites_ = 0;
  clear_has_num_stale_rewrites();
}
inline ::google::protobuf::int32 MetadataCacheInfo::num_stale_rewrites() const {
  return num_stale_rewrites_;
}
inline void MetadataCacheInfo::set_num_stale_rewrites(::google::protobuf::int32 value) {
  set_has_num_stale_rewrites();
  num_stale_rewrites_ = value;
}

// optional int32 num_rewrites_completed = 7;
inline bool MetadataCacheInfo::has_num_rewrites_completed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MetadataCacheInfo::set_has_num_rewrites_completed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MetadataCacheInfo::clear_has_num_rewrites_completed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MetadataCacheInfo::clear_num_rewrites_completed() {
  num_rewrites_completed_ = 0;
  clear_has_num_rewrites_completed();
}
inline ::google::protobuf::int32 MetadataCacheInfo::num_rewrites_completed() const {
  return num_rewrites_completed_;
}
inline void MetadataCacheInfo::set_num_rewrites_completed(::google::protobuf::int32 value) {
  set_has_num_rewrites_completed();
  num_rewrites_completed_ = value;
}

// optional int32 num_disabled_rewrites = 8;
inline bool MetadataCacheInfo::has_num_disabled_rewrites() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MetadataCacheInfo::set_has_num_disabled_rewrites() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MetadataCacheInfo::clear_has_num_disabled_rewrites() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MetadataCacheInfo::clear_num_disabled_rewrites() {
  num_disabled_rewrites_ = 0;
  clear_has_num_disabled_rewrites();
}
inline ::google::protobuf::int32 MetadataCacheInfo::num_disabled_rewrites() const {
  return num_disabled_rewrites_;
}
inline void MetadataCacheInfo::set_num_disabled_rewrites(::google::protobuf::int32 value) {
  set_has_num_disabled_rewrites();
  num_disabled_rewrites_ = value;
}

// optional int32 num_repeated_rewrites = 9;
inline bool MetadataCacheInfo::has_num_repeated_rewrites() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MetadataCacheInfo::set_has_num_repeated_rewrites() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MetadataCacheInfo::clear_has_num_repeated_rewrites() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MetadataCacheInfo::clear_num_repeated_rewrites() {
  num_repeated_rewrites_ = 0;
  clear_has_num_repeated_rewrites();
}
inline ::google::protobuf::int32 MetadataCacheInfo::num_repeated_rewrites() const {
  return num_repeated_rewrites_;
}
inline void MetadataCacheInfo::set_num_repeated_rewrites(::google::protobuf::int32 value) {
  set_has_num_repeated_rewrites();
  num_repeated_rewrites_ = value;
}

// -------------------------------------------------------------------

// RewritingInfo

// -------------------------------------------------------------------

// SplitHtmlInfo

// optional int64 json_size = 1;
inline bool SplitHtmlInfo::has_json_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SplitHtmlInfo::set_has_json_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SplitHtmlInfo::clear_has_json_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SplitHtmlInfo::clear_json_size() {
  json_size_ = GOOGLE_LONGLONG(0);
  clear_has_json_size();
}
inline ::google::protobuf::int64 SplitHtmlInfo::json_size() const {
  return json_size_;
}
inline void SplitHtmlInfo::set_json_size(::google::protobuf::int64 value) {
  set_has_json_size();
  json_size_ = value;
}

// -------------------------------------------------------------------

// PropertyCohortInfo

// optional string name = 1;
inline bool PropertyCohortInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyCohortInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PropertyCohortInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PropertyCohortInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PropertyCohortInfo::name() const {
  return *name_;
}
inline void PropertyCohortInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PropertyCohortInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PropertyCohortInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PropertyCohortInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PropertyCohortInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool is_cache_hit = 2 [default = false];
inline bool PropertyCohortInfo::has_is_cache_hit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PropertyCohortInfo::set_has_is_cache_hit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PropertyCohortInfo::clear_has_is_cache_hit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PropertyCohortInfo::clear_is_cache_hit() {
  is_cache_hit_ = false;
  clear_has_is_cache_hit();
}
inline bool PropertyCohortInfo::is_cache_hit() const {
  return is_cache_hit_;
}
inline void PropertyCohortInfo::set_is_cache_hit(bool value) {
  set_has_is_cache_hit();
  is_cache_hit_ = value;
}

// repeated string properties_found = 3;
inline int PropertyCohortInfo::properties_found_size() const {
  return properties_found_.size();
}
inline void PropertyCohortInfo::clear_properties_found() {
  properties_found_.Clear();
}
inline const ::std::string& PropertyCohortInfo::properties_found(int index) const {
  return properties_found_.Get(index);
}
inline ::std::string* PropertyCohortInfo::mutable_properties_found(int index) {
  return properties_found_.Mutable(index);
}
inline void PropertyCohortInfo::set_properties_found(int index, const ::std::string& value) {
  properties_found_.Mutable(index)->assign(value);
}
inline void PropertyCohortInfo::set_properties_found(int index, const char* value) {
  properties_found_.Mutable(index)->assign(value);
}
inline void PropertyCohortInfo::set_properties_found(int index, const char* value, size_t size) {
  properties_found_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PropertyCohortInfo::add_properties_found() {
  return properties_found_.Add();
}
inline void PropertyCohortInfo::add_properties_found(const ::std::string& value) {
  properties_found_.Add()->assign(value);
}
inline void PropertyCohortInfo::add_properties_found(const char* value) {
  properties_found_.Add()->assign(value);
}
inline void PropertyCohortInfo::add_properties_found(const char* value, size_t size) {
  properties_found_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PropertyCohortInfo::properties_found() const {
  return properties_found_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PropertyCohortInfo::mutable_properties_found() {
  return &properties_found_;
}

// optional int32 device_type = 4;
inline bool PropertyCohortInfo::has_device_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PropertyCohortInfo::set_has_device_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PropertyCohortInfo::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PropertyCohortInfo::clear_device_type() {
  device_type_ = 0;
  clear_has_device_type();
}
inline ::google::protobuf::int32 PropertyCohortInfo::device_type() const {
  return device_type_;
}
inline void PropertyCohortInfo::set_device_type(::google::protobuf::int32 value) {
  set_has_device_type();
  device_type_ = value;
}

// optional int32 cache_type = 5;
inline bool PropertyCohortInfo::has_cache_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PropertyCohortInfo::set_has_cache_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PropertyCohortInfo::clear_has_cache_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PropertyCohortInfo::clear_cache_type() {
  cache_type_ = 0;
  clear_has_cache_type();
}
inline ::google::protobuf::int32 PropertyCohortInfo::cache_type() const {
  return cache_type_;
}
inline void PropertyCohortInfo::set_cache_type(::google::protobuf::int32 value) {
  set_has_cache_type();
  cache_type_ = value;
}

// optional int32 cache_key_state = 6;
inline bool PropertyCohortInfo::has_cache_key_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PropertyCohortInfo::set_has_cache_key_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PropertyCohortInfo::clear_has_cache_key_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PropertyCohortInfo::clear_cache_key_state() {
  cache_key_state_ = 0;
  clear_has_cache_key_state();
}
inline ::google::protobuf::int32 PropertyCohortInfo::cache_key_state() const {
  return cache_key_state_;
}
inline void PropertyCohortInfo::set_cache_key_state(::google::protobuf::int32 value) {
  set_has_cache_key_state();
  cache_key_state_ = value;
}

// -------------------------------------------------------------------

// PropertyPageInfo

// repeated .net_instaweb.PropertyCohortInfo cohort_info = 1;
inline int PropertyPageInfo::cohort_info_size() const {
  return cohort_info_.size();
}
inline void PropertyPageInfo::clear_cohort_info() {
  cohort_info_.Clear();
}
inline const ::net_instaweb::PropertyCohortInfo& PropertyPageInfo::cohort_info(int index) const {
  return cohort_info_.Get(index);
}
inline ::net_instaweb::PropertyCohortInfo* PropertyPageInfo::mutable_cohort_info(int index) {
  return cohort_info_.Mutable(index);
}
inline ::net_instaweb::PropertyCohortInfo* PropertyPageInfo::add_cohort_info() {
  return cohort_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::net_instaweb::PropertyCohortInfo >&
PropertyPageInfo::cohort_info() const {
  return cohort_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::net_instaweb::PropertyCohortInfo >*
PropertyPageInfo::mutable_cohort_info() {
  return &cohort_info_;
}

// -------------------------------------------------------------------

// FlushEarlyFlowInfo

// optional int64 available_time_ms = 1;
inline bool FlushEarlyFlowInfo::has_available_time_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlushEarlyFlowInfo::set_has_available_time_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlushEarlyFlowInfo::clear_has_available_time_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlushEarlyFlowInfo::clear_available_time_ms() {
  available_time_ms_ = GOOGLE_LONGLONG(0);
  clear_has_available_time_ms();
}
inline ::google::protobuf::int64 FlushEarlyFlowInfo::available_time_ms() const {
  return available_time_ms_;
}
inline void FlushEarlyFlowInfo::set_available_time_ms(::google::protobuf::int64 value) {
  set_has_available_time_ms();
  available_time_ms_ = value;
}

// -------------------------------------------------------------------

// FlushEarlyResourceInfo

// optional .net_instaweb.FlushEarlyResourceInfo.ContentType content_type = 1;
inline bool FlushEarlyResourceInfo::has_content_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlushEarlyResourceInfo::set_has_content_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlushEarlyResourceInfo::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlushEarlyResourceInfo::clear_content_type() {
  content_type_ = 0;
  clear_has_content_type();
}
inline ::net_instaweb::FlushEarlyResourceInfo_ContentType FlushEarlyResourceInfo::content_type() const {
  return static_cast< ::net_instaweb::FlushEarlyResourceInfo_ContentType >(content_type_);
}
inline void FlushEarlyResourceInfo::set_content_type(::net_instaweb::FlushEarlyResourceInfo_ContentType value) {
  GOOGLE_DCHECK(::net_instaweb::FlushEarlyResourceInfo_ContentType_IsValid(value));
  set_has_content_type();
  content_type_ = value;
}

// optional .net_instaweb.FlushEarlyResourceInfo.ResourceType resource_type = 2;
inline bool FlushEarlyResourceInfo::has_resource_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlushEarlyResourceInfo::set_has_resource_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlushEarlyResourceInfo::clear_has_resource_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlushEarlyResourceInfo::clear_resource_type() {
  resource_type_ = 0;
  clear_has_resource_type();
}
inline ::net_instaweb::FlushEarlyResourceInfo_ResourceType FlushEarlyResourceInfo::resource_type() const {
  return static_cast< ::net_instaweb::FlushEarlyResourceInfo_ResourceType >(resource_type_);
}
inline void FlushEarlyResourceInfo::set_resource_type(::net_instaweb::FlushEarlyResourceInfo_ResourceType value) {
  GOOGLE_DCHECK(::net_instaweb::FlushEarlyResourceInfo_ResourceType_IsValid(value));
  set_has_resource_type();
  resource_type_ = value;
}

// optional bool is_bandwidth_affected = 3;
inline bool FlushEarlyResourceInfo::has_is_bandwidth_affected() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FlushEarlyResourceInfo::set_has_is_bandwidth_affected() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FlushEarlyResourceInfo::clear_has_is_bandwidth_affected() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FlushEarlyResourceInfo::clear_is_bandwidth_affected() {
  is_bandwidth_affected_ = false;
  clear_has_is_bandwidth_affected();
}
inline bool FlushEarlyResourceInfo::is_bandwidth_affected() const {
  return is_bandwidth_affected_;
}
inline void FlushEarlyResourceInfo::set_is_bandwidth_affected(bool value) {
  set_has_is_bandwidth_affected();
  is_bandwidth_affected_ = value;
}

// optional bool in_head = 4;
inline bool FlushEarlyResourceInfo::has_in_head() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FlushEarlyResourceInfo::set_has_in_head() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FlushEarlyResourceInfo::clear_has_in_head() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FlushEarlyResourceInfo::clear_in_head() {
  in_head_ = false;
  clear_has_in_head();
}
inline bool FlushEarlyResourceInfo::in_head() const {
  return in_head_;
}
inline void FlushEarlyResourceInfo::set_in_head(bool value) {
  set_has_in_head();
  in_head_ = value;
}

// -------------------------------------------------------------------

// CriticalCssInfo

// optional int64 critical_inlined_bytes = 1;
inline bool CriticalCssInfo::has_critical_inlined_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CriticalCssInfo::set_has_critical_inlined_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CriticalCssInfo::clear_has_critical_inlined_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CriticalCssInfo::clear_critical_inlined_bytes() {
  critical_inlined_bytes_ = GOOGLE_LONGLONG(0);
  clear_has_critical_inlined_bytes();
}
inline ::google::protobuf::int64 CriticalCssInfo::critical_inlined_bytes() const {
  return critical_inlined_bytes_;
}
inline void CriticalCssInfo::set_critical_inlined_bytes(::google::protobuf::int64 value) {
  set_has_critical_inlined_bytes();
  critical_inlined_bytes_ = value;
}

// optional int64 original_external_bytes = 2;
inline bool CriticalCssInfo::has_original_external_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CriticalCssInfo::set_has_original_external_bytes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CriticalCssInfo::clear_has_original_external_bytes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CriticalCssInfo::clear_original_external_bytes() {
  original_external_bytes_ = GOOGLE_LONGLONG(0);
  clear_has_original_external_bytes();
}
inline ::google::protobuf::int64 CriticalCssInfo::original_external_bytes() const {
  return original_external_bytes_;
}
inline void CriticalCssInfo::set_original_external_bytes(::google::protobuf::int64 value) {
  set_has_original_external_bytes();
  original_external_bytes_ = value;
}

// optional int64 overhead_bytes = 3;
inline bool CriticalCssInfo::has_overhead_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CriticalCssInfo::set_has_overhead_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CriticalCssInfo::clear_has_overhead_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CriticalCssInfo::clear_overhead_bytes() {
  overhead_bytes_ = GOOGLE_LONGLONG(0);
  clear_has_overhead_bytes();
}
inline ::google::protobuf::int64 CriticalCssInfo::overhead_bytes() const {
  return overhead_bytes_;
}
inline void CriticalCssInfo::set_overhead_bytes(::google::protobuf::int64 value) {
  set_has_overhead_bytes();
  overhead_bytes_ = value;
}

// -------------------------------------------------------------------

// CacheHtmlLoggingInfo

// optional .net_instaweb.CacheHtmlLoggingInfo.CacheHtmlRequestFlow cache_html_request_flow = 1;
inline bool CacheHtmlLoggingInfo::has_cache_html_request_flow() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CacheHtmlLoggingInfo::set_has_cache_html_request_flow() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CacheHtmlLoggingInfo::clear_has_cache_html_request_flow() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CacheHtmlLoggingInfo::clear_cache_html_request_flow() {
  cache_html_request_flow_ = 1;
  clear_has_cache_html_request_flow();
}
inline ::net_instaweb::CacheHtmlLoggingInfo_CacheHtmlRequestFlow CacheHtmlLoggingInfo::cache_html_request_flow() const {
  return static_cast< ::net_instaweb::CacheHtmlLoggingInfo_CacheHtmlRequestFlow >(cache_html_request_flow_);
}
inline void CacheHtmlLoggingInfo::set_cache_html_request_flow(::net_instaweb::CacheHtmlLoggingInfo_CacheHtmlRequestFlow value) {
  GOOGLE_DCHECK(::net_instaweb::CacheHtmlLoggingInfo_CacheHtmlRequestFlow_IsValid(value));
  set_has_cache_html_request_flow();
  cache_html_request_flow_ = value;
}

// optional string request_event_id_time_usec = 2;
inline bool CacheHtmlLoggingInfo::has_request_event_id_time_usec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CacheHtmlLoggingInfo::set_has_request_event_id_time_usec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CacheHtmlLoggingInfo::clear_has_request_event_id_time_usec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CacheHtmlLoggingInfo::clear_request_event_id_time_usec() {
  if (request_event_id_time_usec_ != &::google::protobuf::internal::kEmptyString) {
    request_event_id_time_usec_->clear();
  }
  clear_has_request_event_id_time_usec();
}
inline const ::std::string& CacheHtmlLoggingInfo::request_event_id_time_usec() const {
  return *request_event_id_time_usec_;
}
inline void CacheHtmlLoggingInfo::set_request_event_id_time_usec(const ::std::string& value) {
  set_has_request_event_id_time_usec();
  if (request_event_id_time_usec_ == &::google::protobuf::internal::kEmptyString) {
    request_event_id_time_usec_ = new ::std::string;
  }
  request_event_id_time_usec_->assign(value);
}
inline void CacheHtmlLoggingInfo::set_request_event_id_time_usec(const char* value) {
  set_has_request_event_id_time_usec();
  if (request_event_id_time_usec_ == &::google::protobuf::internal::kEmptyString) {
    request_event_id_time_usec_ = new ::std::string;
  }
  request_event_id_time_usec_->assign(value);
}
inline void CacheHtmlLoggingInfo::set_request_event_id_time_usec(const char* value, size_t size) {
  set_has_request_event_id_time_usec();
  if (request_event_id_time_usec_ == &::google::protobuf::internal::kEmptyString) {
    request_event_id_time_usec_ = new ::std::string;
  }
  request_event_id_time_usec_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CacheHtmlLoggingInfo::mutable_request_event_id_time_usec() {
  set_has_request_event_id_time_usec();
  if (request_event_id_time_usec_ == &::google::protobuf::internal::kEmptyString) {
    request_event_id_time_usec_ = new ::std::string;
  }
  return request_event_id_time_usec_;
}
inline ::std::string* CacheHtmlLoggingInfo::release_request_event_id_time_usec() {
  clear_has_request_event_id_time_usec();
  if (request_event_id_time_usec_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_event_id_time_usec_;
    request_event_id_time_usec_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool html_match = 3;
inline bool CacheHtmlLoggingInfo::has_html_match() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CacheHtmlLoggingInfo::set_has_html_match() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CacheHtmlLoggingInfo::clear_has_html_match() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CacheHtmlLoggingInfo::clear_html_match() {
  html_match_ = false;
  clear_has_html_match();
}
inline bool CacheHtmlLoggingInfo::html_match() const {
  return html_match_;
}
inline void CacheHtmlLoggingInfo::set_html_match(bool value) {
  set_has_html_match();
  html_match_ = value;
}

// optional bool html_smart_diff_match = 4;
inline bool CacheHtmlLoggingInfo::has_html_smart_diff_match() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CacheHtmlLoggingInfo::set_has_html_smart_diff_match() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CacheHtmlLoggingInfo::clear_has_html_smart_diff_match() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CacheHtmlLoggingInfo::clear_html_smart_diff_match() {
  html_smart_diff_match_ = false;
  clear_has_html_smart_diff_match();
}
inline bool CacheHtmlLoggingInfo::html_smart_diff_match() const {
  return html_smart_diff_match_;
}
inline void CacheHtmlLoggingInfo::set_html_smart_diff_match(bool value) {
  set_has_html_smart_diff_match();
  html_smart_diff_match_ = value;
}

// optional string url = 5;
inline bool CacheHtmlLoggingInfo::has_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CacheHtmlLoggingInfo::set_has_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CacheHtmlLoggingInfo::clear_has_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CacheHtmlLoggingInfo::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& CacheHtmlLoggingInfo::url() const {
  return *url_;
}
inline void CacheHtmlLoggingInfo::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void CacheHtmlLoggingInfo::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void CacheHtmlLoggingInfo::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CacheHtmlLoggingInfo::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* CacheHtmlLoggingInfo::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RewriteResourceInfo

// optional bool is_inlined = 1 [default = false];
inline bool RewriteResourceInfo::has_is_inlined() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewriteResourceInfo::set_has_is_inlined() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewriteResourceInfo::clear_has_is_inlined() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewriteResourceInfo::clear_is_inlined() {
  is_inlined_ = false;
  clear_has_is_inlined();
}
inline bool RewriteResourceInfo::is_inlined() const {
  return is_inlined_;
}
inline void RewriteResourceInfo::set_is_inlined(bool value) {
  set_has_is_inlined();
  is_inlined_ = value;
}

// optional bool is_critical = 2 [default = false];
inline bool RewriteResourceInfo::has_is_critical() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewriteResourceInfo::set_has_is_critical() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewriteResourceInfo::clear_has_is_critical() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewriteResourceInfo::clear_is_critical() {
  is_critical_ = false;
  clear_has_is_critical();
}
inline bool RewriteResourceInfo::is_critical() const {
  return is_critical_;
}
inline void RewriteResourceInfo::set_is_critical(bool value) {
  set_has_is_critical();
  is_critical_ = value;
}

// optional bool has_pagespeed_no_defer = 3 [default = false];
inline bool RewriteResourceInfo::has_has_pagespeed_no_defer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RewriteResourceInfo::set_has_has_pagespeed_no_defer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RewriteResourceInfo::clear_has_has_pagespeed_no_defer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RewriteResourceInfo::clear_has_pagespeed_no_defer() {
  has_pagespeed_no_defer_ = false;
  clear_has_has_pagespeed_no_defer();
}
inline bool RewriteResourceInfo::has_pagespeed_no_defer() const {
  return has_pagespeed_no_defer_;
}
inline void RewriteResourceInfo::set_has_pagespeed_no_defer(bool value) {
  set_has_has_pagespeed_no_defer();
  has_pagespeed_no_defer_ = value;
}

// optional bool is_blacklisted = 4 [default = false];
inline bool RewriteResourceInfo::has_is_blacklisted() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RewriteResourceInfo::set_has_is_blacklisted() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RewriteResourceInfo::clear_has_is_blacklisted() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RewriteResourceInfo::clear_is_blacklisted() {
  is_blacklisted_ = false;
  clear_has_is_blacklisted();
}
inline bool RewriteResourceInfo::is_blacklisted() const {
  return is_blacklisted_;
}
inline void RewriteResourceInfo::set_is_blacklisted(bool value) {
  set_has_is_blacklisted();
  is_blacklisted_ = value;
}

// optional int32 original_resource_url_index = 5 [default = -1];
inline bool RewriteResourceInfo::has_original_resource_url_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RewriteResourceInfo::set_has_original_resource_url_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RewriteResourceInfo::clear_has_original_resource_url_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RewriteResourceInfo::clear_original_resource_url_index() {
  original_resource_url_index_ = -1;
  clear_has_original_resource_url_index();
}
inline ::google::protobuf::int32 RewriteResourceInfo::original_resource_url_index() const {
  return original_resource_url_index_;
}
inline void RewriteResourceInfo::set_original_resource_url_index(::google::protobuf::int32 value) {
  set_has_original_resource_url_index();
  original_resource_url_index_ = value;
}

// -------------------------------------------------------------------

// ImageRewriteResourceInfo

// optional bool is_low_res_src_inserted = 1 [default = false];
inline bool ImageRewriteResourceInfo::has_is_low_res_src_inserted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageRewriteResourceInfo::set_has_is_low_res_src_inserted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageRewriteResourceInfo::clear_has_is_low_res_src_inserted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageRewriteResourceInfo::clear_is_low_res_src_inserted() {
  is_low_res_src_inserted_ = false;
  clear_has_is_low_res_src_inserted();
}
inline bool ImageRewriteResourceInfo::is_low_res_src_inserted() const {
  return is_low_res_src_inserted_;
}
inline void ImageRewriteResourceInfo::set_is_low_res_src_inserted(bool value) {
  set_has_is_low_res_src_inserted();
  is_low_res_src_inserted_ = value;
}

// optional int32 low_res_size = 2 [default = 0];
inline bool ImageRewriteResourceInfo::has_low_res_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageRewriteResourceInfo::set_has_low_res_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageRewriteResourceInfo::clear_has_low_res_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageRewriteResourceInfo::clear_low_res_size() {
  low_res_size_ = 0;
  clear_has_low_res_size();
}
inline ::google::protobuf::int32 ImageRewriteResourceInfo::low_res_size() const {
  return low_res_size_;
}
inline void ImageRewriteResourceInfo::set_low_res_size(::google::protobuf::int32 value) {
  set_has_low_res_size();
  low_res_size_ = value;
}

// -------------------------------------------------------------------

// RewriterInfo

// optional string id = 1;
inline bool RewriterInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewriterInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewriterInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewriterInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& RewriterInfo::id() const {
  return *id_;
}
inline void RewriterInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void RewriterInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void RewriterInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RewriterInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* RewriterInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .net_instaweb.RewriterInfo.RewriterApplicationStatus status = 2;
inline bool RewriterInfo::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewriterInfo::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewriterInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewriterInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::net_instaweb::RewriterInfo_RewriterApplicationStatus RewriterInfo::status() const {
  return static_cast< ::net_instaweb::RewriterInfo_RewriterApplicationStatus >(status_);
}
inline void RewriterInfo::set_status(::net_instaweb::RewriterInfo_RewriterApplicationStatus value) {
  GOOGLE_DCHECK(::net_instaweb::RewriterInfo_RewriterApplicationStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .net_instaweb.FlushEarlyResourceInfo flush_early_resource_info = 3;
inline bool RewriterInfo::has_flush_early_resource_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RewriterInfo::set_has_flush_early_resource_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RewriterInfo::clear_has_flush_early_resource_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RewriterInfo::clear_flush_early_resource_info() {
  if (flush_early_resource_info_ != NULL) flush_early_resource_info_->::net_instaweb::FlushEarlyResourceInfo::Clear();
  clear_has_flush_early_resource_info();
}
inline const ::net_instaweb::FlushEarlyResourceInfo& RewriterInfo::flush_early_resource_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return flush_early_resource_info_ != NULL ? *flush_early_resource_info_ : *default_instance().flush_early_resource_info_;
#else
  return flush_early_resource_info_ != NULL ? *flush_early_resource_info_ : *default_instance_->flush_early_resource_info_;
#endif
}
inline ::net_instaweb::FlushEarlyResourceInfo* RewriterInfo::mutable_flush_early_resource_info() {
  set_has_flush_early_resource_info();
  if (flush_early_resource_info_ == NULL) flush_early_resource_info_ = new ::net_instaweb::FlushEarlyResourceInfo;
  return flush_early_resource_info_;
}
inline ::net_instaweb::FlushEarlyResourceInfo* RewriterInfo::release_flush_early_resource_info() {
  clear_has_flush_early_resource_info();
  ::net_instaweb::FlushEarlyResourceInfo* temp = flush_early_resource_info_;
  flush_early_resource_info_ = NULL;
  return temp;
}

// optional .net_instaweb.RewriteResourceInfo rewrite_resource_info = 4;
inline bool RewriterInfo::has_rewrite_resource_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RewriterInfo::set_has_rewrite_resource_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RewriterInfo::clear_has_rewrite_resource_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RewriterInfo::clear_rewrite_resource_info() {
  if (rewrite_resource_info_ != NULL) rewrite_resource_info_->::net_instaweb::RewriteResourceInfo::Clear();
  clear_has_rewrite_resource_info();
}
inline const ::net_instaweb::RewriteResourceInfo& RewriterInfo::rewrite_resource_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rewrite_resource_info_ != NULL ? *rewrite_resource_info_ : *default_instance().rewrite_resource_info_;
#else
  return rewrite_resource_info_ != NULL ? *rewrite_resource_info_ : *default_instance_->rewrite_resource_info_;
#endif
}
inline ::net_instaweb::RewriteResourceInfo* RewriterInfo::mutable_rewrite_resource_info() {
  set_has_rewrite_resource_info();
  if (rewrite_resource_info_ == NULL) rewrite_resource_info_ = new ::net_instaweb::RewriteResourceInfo;
  return rewrite_resource_info_;
}
inline ::net_instaweb::RewriteResourceInfo* RewriterInfo::release_rewrite_resource_info() {
  clear_has_rewrite_resource_info();
  ::net_instaweb::RewriteResourceInfo* temp = rewrite_resource_info_;
  rewrite_resource_info_ = NULL;
  return temp;
}

// optional .net_instaweb.ImageRewriteResourceInfo image_rewrite_resource_info = 5;
inline bool RewriterInfo::has_image_rewrite_resource_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RewriterInfo::set_has_image_rewrite_resource_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RewriterInfo::clear_has_image_rewrite_resource_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RewriterInfo::clear_image_rewrite_resource_info() {
  if (image_rewrite_resource_info_ != NULL) image_rewrite_resource_info_->::net_instaweb::ImageRewriteResourceInfo::Clear();
  clear_has_image_rewrite_resource_info();
}
inline const ::net_instaweb::ImageRewriteResourceInfo& RewriterInfo::image_rewrite_resource_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return image_rewrite_resource_info_ != NULL ? *image_rewrite_resource_info_ : *default_instance().image_rewrite_resource_info_;
#else
  return image_rewrite_resource_info_ != NULL ? *image_rewrite_resource_info_ : *default_instance_->image_rewrite_resource_info_;
#endif
}
inline ::net_instaweb::ImageRewriteResourceInfo* RewriterInfo::mutable_image_rewrite_resource_info() {
  set_has_image_rewrite_resource_info();
  if (image_rewrite_resource_info_ == NULL) image_rewrite_resource_info_ = new ::net_instaweb::ImageRewriteResourceInfo;
  return image_rewrite_resource_info_;
}
inline ::net_instaweb::ImageRewriteResourceInfo* RewriterInfo::release_image_rewrite_resource_info() {
  clear_has_image_rewrite_resource_info();
  ::net_instaweb::ImageRewriteResourceInfo* temp = image_rewrite_resource_info_;
  image_rewrite_resource_info_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ResourceUrlInfo

// repeated string url = 1;
inline int ResourceUrlInfo::url_size() const {
  return url_.size();
}
inline void ResourceUrlInfo::clear_url() {
  url_.Clear();
}
inline const ::std::string& ResourceUrlInfo::url(int index) const {
  return url_.Get(index);
}
inline ::std::string* ResourceUrlInfo::mutable_url(int index) {
  return url_.Mutable(index);
}
inline void ResourceUrlInfo::set_url(int index, const ::std::string& value) {
  url_.Mutable(index)->assign(value);
}
inline void ResourceUrlInfo::set_url(int index, const char* value) {
  url_.Mutable(index)->assign(value);
}
inline void ResourceUrlInfo::set_url(int index, const char* value, size_t size) {
  url_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceUrlInfo::add_url() {
  return url_.Add();
}
inline void ResourceUrlInfo::add_url(const ::std::string& value) {
  url_.Add()->assign(value);
}
inline void ResourceUrlInfo::add_url(const char* value) {
  url_.Add()->assign(value);
}
inline void ResourceUrlInfo::add_url(const char* value, size_t size) {
  url_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResourceUrlInfo::url() const {
  return url_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResourceUrlInfo::mutable_url() {
  return &url_;
}

// -------------------------------------------------------------------

// ImageStats

// optional int32 num_img_tags = 1;
inline bool ImageStats::has_num_img_tags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageStats::set_has_num_img_tags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageStats::clear_has_num_img_tags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageStats::clear_num_img_tags() {
  num_img_tags_ = 0;
  clear_has_num_img_tags();
}
inline ::google::protobuf::int32 ImageStats::num_img_tags() const {
  return num_img_tags_;
}
inline void ImageStats::set_num_img_tags(::google::protobuf::int32 value) {
  set_has_num_img_tags();
  num_img_tags_ = value;
}

// optional int32 num_inlined_img_tags = 2;
inline bool ImageStats::has_num_inlined_img_tags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageStats::set_has_num_inlined_img_tags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageStats::clear_has_num_inlined_img_tags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageStats::clear_num_inlined_img_tags() {
  num_inlined_img_tags_ = 0;
  clear_has_num_inlined_img_tags();
}
inline ::google::protobuf::int32 ImageStats::num_inlined_img_tags() const {
  return num_inlined_img_tags_;
}
inline void ImageStats::set_num_inlined_img_tags(::google::protobuf::int32 value) {
  set_has_num_inlined_img_tags();
  num_inlined_img_tags_ = value;
}

// -------------------------------------------------------------------

// RewriteStatusCount

// optional int32 application_status = 1;
inline bool RewriteStatusCount::has_application_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewriteStatusCount::set_has_application_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewriteStatusCount::clear_has_application_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewriteStatusCount::clear_application_status() {
  application_status_ = 0;
  clear_has_application_status();
}
inline ::google::protobuf::int32 RewriteStatusCount::application_status() const {
  return application_status_;
}
inline void RewriteStatusCount::set_application_status(::google::protobuf::int32 value) {
  set_has_application_status();
  application_status_ = value;
}

// optional int32 count = 2;
inline bool RewriteStatusCount::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewriteStatusCount::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewriteStatusCount::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewriteStatusCount::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 RewriteStatusCount::count() const {
  return count_;
}
inline void RewriteStatusCount::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// RewriterStats

// optional string id = 1;
inline bool RewriterStats::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewriterStats::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewriterStats::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewriterStats::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& RewriterStats::id() const {
  return *id_;
}
inline void RewriterStats::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void RewriterStats::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void RewriterStats::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RewriterStats::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* RewriterStats::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .net_instaweb.RewriterStats.RewriterHtmlStatus html_status = 2;
inline bool RewriterStats::has_html_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewriterStats::set_has_html_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewriterStats::clear_has_html_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewriterStats::clear_html_status() {
  html_status_ = 0;
  clear_has_html_status();
}
inline ::net_instaweb::RewriterStats_RewriterHtmlStatus RewriterStats::html_status() const {
  return static_cast< ::net_instaweb::RewriterStats_RewriterHtmlStatus >(html_status_);
}
inline void RewriterStats::set_html_status(::net_instaweb::RewriterStats_RewriterHtmlStatus value) {
  GOOGLE_DCHECK(::net_instaweb::RewriterStats_RewriterHtmlStatus_IsValid(value));
  set_has_html_status();
  html_status_ = value;
}

// repeated .net_instaweb.RewriteStatusCount status_counts = 3;
inline int RewriterStats::status_counts_size() const {
  return status_counts_.size();
}
inline void RewriterStats::clear_status_counts() {
  status_counts_.Clear();
}
inline const ::net_instaweb::RewriteStatusCount& RewriterStats::status_counts(int index) const {
  return status_counts_.Get(index);
}
inline ::net_instaweb::RewriteStatusCount* RewriterStats::mutable_status_counts(int index) {
  return status_counts_.Mutable(index);
}
inline ::net_instaweb::RewriteStatusCount* RewriterStats::add_status_counts() {
  return status_counts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriteStatusCount >&
RewriterStats::status_counts() const {
  return status_counts_;
}
inline ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriteStatusCount >*
RewriterStats::mutable_status_counts() {
  return &status_counts_;
}

// -------------------------------------------------------------------

// DeviceInfo

// optional int32 device_type = 1;
inline bool DeviceInfo::has_device_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceInfo::set_has_device_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceInfo::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceInfo::clear_device_type() {
  device_type_ = 0;
  clear_has_device_type();
}
inline ::google::protobuf::int32 DeviceInfo::device_type() const {
  return device_type_;
}
inline void DeviceInfo::set_device_type(::google::protobuf::int32 value) {
  set_has_device_type();
  device_type_ = value;
}

// optional bool supports_image_inlining = 2;
inline bool DeviceInfo::has_supports_image_inlining() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceInfo::set_has_supports_image_inlining() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceInfo::clear_has_supports_image_inlining() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceInfo::clear_supports_image_inlining() {
  supports_image_inlining_ = false;
  clear_has_supports_image_inlining();
}
inline bool DeviceInfo::supports_image_inlining() const {
  return supports_image_inlining_;
}
inline void DeviceInfo::set_supports_image_inlining(bool value) {
  set_has_supports_image_inlining();
  supports_image_inlining_ = value;
}

// optional bool supports_lazyload_images = 3;
inline bool DeviceInfo::has_supports_lazyload_images() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceInfo::set_has_supports_lazyload_images() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceInfo::clear_has_supports_lazyload_images() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceInfo::clear_supports_lazyload_images() {
  supports_lazyload_images_ = false;
  clear_has_supports_lazyload_images();
}
inline bool DeviceInfo::supports_lazyload_images() const {
  return supports_lazyload_images_;
}
inline void DeviceInfo::set_supports_lazyload_images(bool value) {
  set_has_supports_lazyload_images();
  supports_lazyload_images_ = value;
}

// optional bool supports_critical_images_beacon = 4;
inline bool DeviceInfo::has_supports_critical_images_beacon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceInfo::set_has_supports_critical_images_beacon() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceInfo::clear_has_supports_critical_images_beacon() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceInfo::clear_supports_critical_images_beacon() {
  supports_critical_images_beacon_ = false;
  clear_has_supports_critical_images_beacon();
}
inline bool DeviceInfo::supports_critical_images_beacon() const {
  return supports_critical_images_beacon_;
}
inline void DeviceInfo::set_supports_critical_images_beacon(bool value) {
  set_has_supports_critical_images_beacon();
  supports_critical_images_beacon_ = value;
}

// optional bool supports_deferjs = 5;
inline bool DeviceInfo::has_supports_deferjs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceInfo::set_has_supports_deferjs() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceInfo::clear_has_supports_deferjs() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceInfo::clear_supports_deferjs() {
  supports_deferjs_ = false;
  clear_has_supports_deferjs();
}
inline bool DeviceInfo::supports_deferjs() const {
  return supports_deferjs_;
}
inline void DeviceInfo::set_supports_deferjs(bool value) {
  set_has_supports_deferjs();
  supports_deferjs_ = value;
}

// optional bool supports_webp = 6;
inline bool DeviceInfo::has_supports_webp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceInfo::set_has_supports_webp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceInfo::clear_has_supports_webp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceInfo::clear_supports_webp() {
  supports_webp_ = false;
  clear_has_supports_webp();
}
inline bool DeviceInfo::supports_webp() const {
  return supports_webp_;
}
inline void DeviceInfo::set_supports_webp(bool value) {
  set_has_supports_webp();
  supports_webp_ = value;
}

// optional bool supports_webplossless_alpha = 7;
inline bool DeviceInfo::has_supports_webplossless_alpha() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceInfo::set_has_supports_webplossless_alpha() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DeviceInfo::clear_has_supports_webplossless_alpha() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceInfo::clear_supports_webplossless_alpha() {
  supports_webplossless_alpha_ = false;
  clear_has_supports_webplossless_alpha();
}
inline bool DeviceInfo::supports_webplossless_alpha() const {
  return supports_webplossless_alpha_;
}
inline void DeviceInfo::set_supports_webplossless_alpha(bool value) {
  set_has_supports_webplossless_alpha();
  supports_webplossless_alpha_ = value;
}

// optional bool is_bot = 8;
inline bool DeviceInfo::has_is_bot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceInfo::set_has_is_bot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeviceInfo::clear_has_is_bot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceInfo::clear_is_bot() {
  is_bot_ = false;
  clear_has_is_bot();
}
inline bool DeviceInfo::is_bot() const {
  return is_bot_;
}
inline void DeviceInfo::set_is_bot(bool value) {
  set_has_is_bot();
  is_bot_ = value;
}

// optional bool supports_split_html = 9;
inline bool DeviceInfo::has_supports_split_html() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceInfo::set_has_supports_split_html() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DeviceInfo::clear_has_supports_split_html() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DeviceInfo::clear_supports_split_html() {
  supports_split_html_ = false;
  clear_has_supports_split_html();
}
inline bool DeviceInfo::supports_split_html() const {
  return supports_split_html_;
}
inline void DeviceInfo::set_supports_split_html(bool value) {
  set_has_supports_split_html();
  supports_split_html_ = value;
}

// optional bool can_preload_resources = 10;
inline bool DeviceInfo::has_can_preload_resources() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceInfo::set_has_can_preload_resources() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DeviceInfo::clear_has_can_preload_resources() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DeviceInfo::clear_can_preload_resources() {
  can_preload_resources_ = false;
  clear_has_can_preload_resources();
}
inline bool DeviceInfo::can_preload_resources() const {
  return can_preload_resources_;
}
inline void DeviceInfo::set_can_preload_resources(bool value) {
  set_has_can_preload_resources();
  can_preload_resources_ = value;
}

// -------------------------------------------------------------------

// LoggingInfo

// optional .net_instaweb.TimingInfo timing_info = 1;
inline bool LoggingInfo::has_timing_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoggingInfo::set_has_timing_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoggingInfo::clear_has_timing_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoggingInfo::clear_timing_info() {
  if (timing_info_ != NULL) timing_info_->::net_instaweb::TimingInfo::Clear();
  clear_has_timing_info();
}
inline const ::net_instaweb::TimingInfo& LoggingInfo::timing_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return timing_info_ != NULL ? *timing_info_ : *default_instance().timing_info_;
#else
  return timing_info_ != NULL ? *timing_info_ : *default_instance_->timing_info_;
#endif
}
inline ::net_instaweb::TimingInfo* LoggingInfo::mutable_timing_info() {
  set_has_timing_info();
  if (timing_info_ == NULL) timing_info_ = new ::net_instaweb::TimingInfo;
  return timing_info_;
}
inline ::net_instaweb::TimingInfo* LoggingInfo::release_timing_info() {
  clear_has_timing_info();
  ::net_instaweb::TimingInfo* temp = timing_info_;
  timing_info_ = NULL;
  return temp;
}

// optional .net_instaweb.BlinkInfo blink_info = 2;
inline bool LoggingInfo::has_blink_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoggingInfo::set_has_blink_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoggingInfo::clear_has_blink_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoggingInfo::clear_blink_info() {
  if (blink_info_ != NULL) blink_info_->::net_instaweb::BlinkInfo::Clear();
  clear_has_blink_info();
}
inline const ::net_instaweb::BlinkInfo& LoggingInfo::blink_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return blink_info_ != NULL ? *blink_info_ : *default_instance().blink_info_;
#else
  return blink_info_ != NULL ? *blink_info_ : *default_instance_->blink_info_;
#endif
}
inline ::net_instaweb::BlinkInfo* LoggingInfo::mutable_blink_info() {
  set_has_blink_info();
  if (blink_info_ == NULL) blink_info_ = new ::net_instaweb::BlinkInfo;
  return blink_info_;
}
inline ::net_instaweb::BlinkInfo* LoggingInfo::release_blink_info() {
  clear_has_blink_info();
  ::net_instaweb::BlinkInfo* temp = blink_info_;
  blink_info_ = NULL;
  return temp;
}

// optional string applied_rewriters = 3;
inline bool LoggingInfo::has_applied_rewriters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoggingInfo::set_has_applied_rewriters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoggingInfo::clear_has_applied_rewriters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoggingInfo::clear_applied_rewriters() {
  if (applied_rewriters_ != &::google::protobuf::internal::kEmptyString) {
    applied_rewriters_->clear();
  }
  clear_has_applied_rewriters();
}
inline const ::std::string& LoggingInfo::applied_rewriters() const {
  return *applied_rewriters_;
}
inline void LoggingInfo::set_applied_rewriters(const ::std::string& value) {
  set_has_applied_rewriters();
  if (applied_rewriters_ == &::google::protobuf::internal::kEmptyString) {
    applied_rewriters_ = new ::std::string;
  }
  applied_rewriters_->assign(value);
}
inline void LoggingInfo::set_applied_rewriters(const char* value) {
  set_has_applied_rewriters();
  if (applied_rewriters_ == &::google::protobuf::internal::kEmptyString) {
    applied_rewriters_ = new ::std::string;
  }
  applied_rewriters_->assign(value);
}
inline void LoggingInfo::set_applied_rewriters(const char* value, size_t size) {
  set_has_applied_rewriters();
  if (applied_rewriters_ == &::google::protobuf::internal::kEmptyString) {
    applied_rewriters_ = new ::std::string;
  }
  applied_rewriters_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoggingInfo::mutable_applied_rewriters() {
  set_has_applied_rewriters();
  if (applied_rewriters_ == &::google::protobuf::internal::kEmptyString) {
    applied_rewriters_ = new ::std::string;
  }
  return applied_rewriters_;
}
inline ::std::string* LoggingInfo::release_applied_rewriters() {
  clear_has_applied_rewriters();
  if (applied_rewriters_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = applied_rewriters_;
    applied_rewriters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .net_instaweb.MetadataCacheInfo metadata_cache_info = 4;
inline bool LoggingInfo::has_metadata_cache_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoggingInfo::set_has_metadata_cache_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoggingInfo::clear_has_metadata_cache_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoggingInfo::clear_metadata_cache_info() {
  if (metadata_cache_info_ != NULL) metadata_cache_info_->::net_instaweb::MetadataCacheInfo::Clear();
  clear_has_metadata_cache_info();
}
inline const ::net_instaweb::MetadataCacheInfo& LoggingInfo::metadata_cache_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return metadata_cache_info_ != NULL ? *metadata_cache_info_ : *default_instance().metadata_cache_info_;
#else
  return metadata_cache_info_ != NULL ? *metadata_cache_info_ : *default_instance_->metadata_cache_info_;
#endif
}
inline ::net_instaweb::MetadataCacheInfo* LoggingInfo::mutable_metadata_cache_info() {
  set_has_metadata_cache_info();
  if (metadata_cache_info_ == NULL) metadata_cache_info_ = new ::net_instaweb::MetadataCacheInfo;
  return metadata_cache_info_;
}
inline ::net_instaweb::MetadataCacheInfo* LoggingInfo::release_metadata_cache_info() {
  clear_has_metadata_cache_info();
  ::net_instaweb::MetadataCacheInfo* temp = metadata_cache_info_;
  metadata_cache_info_ = NULL;
  return temp;
}

// optional bool is_original_resource_cacheable = 5 [default = true];
inline bool LoggingInfo::has_is_original_resource_cacheable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoggingInfo::set_has_is_original_resource_cacheable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoggingInfo::clear_has_is_original_resource_cacheable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoggingInfo::clear_is_original_resource_cacheable() {
  is_original_resource_cacheable_ = true;
  clear_has_is_original_resource_cacheable();
}
inline bool LoggingInfo::is_original_resource_cacheable() const {
  return is_original_resource_cacheable_;
}
inline void LoggingInfo::set_is_original_resource_cacheable(bool value) {
  set_has_is_original_resource_cacheable();
  is_original_resource_cacheable_ = value;
}

// optional int32 furious_id = 6;
inline bool LoggingInfo::has_furious_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoggingInfo::set_has_furious_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoggingInfo::clear_has_furious_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoggingInfo::clear_furious_id() {
  furious_id_ = 0;
  clear_has_furious_id();
}
inline ::google::protobuf::int32 LoggingInfo::furious_id() const {
  return furious_id_;
}
inline void LoggingInfo::set_furious_id(::google::protobuf::int32 value) {
  set_has_furious_id();
  furious_id_ = value;
}

// optional .net_instaweb.SplitHtmlInfo split_html_info = 7;
inline bool LoggingInfo::has_split_html_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoggingInfo::set_has_split_html_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoggingInfo::clear_has_split_html_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoggingInfo::clear_split_html_info() {
  if (split_html_info_ != NULL) split_html_info_->::net_instaweb::SplitHtmlInfo::Clear();
  clear_has_split_html_info();
}
inline const ::net_instaweb::SplitHtmlInfo& LoggingInfo::split_html_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return split_html_info_ != NULL ? *split_html_info_ : *default_instance().split_html_info_;
#else
  return split_html_info_ != NULL ? *split_html_info_ : *default_instance_->split_html_info_;
#endif
}
inline ::net_instaweb::SplitHtmlInfo* LoggingInfo::mutable_split_html_info() {
  set_has_split_html_info();
  if (split_html_info_ == NULL) split_html_info_ = new ::net_instaweb::SplitHtmlInfo;
  return split_html_info_;
}
inline ::net_instaweb::SplitHtmlInfo* LoggingInfo::release_split_html_info() {
  clear_has_split_html_info();
  ::net_instaweb::SplitHtmlInfo* temp = split_html_info_;
  split_html_info_ = NULL;
  return temp;
}

// optional .net_instaweb.PropertyPageInfo property_page_info = 8;
inline bool LoggingInfo::has_property_page_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoggingInfo::set_has_property_page_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoggingInfo::clear_has_property_page_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoggingInfo::clear_property_page_info() {
  if (property_page_info_ != NULL) property_page_info_->::net_instaweb::PropertyPageInfo::Clear();
  clear_has_property_page_info();
}
inline const ::net_instaweb::PropertyPageInfo& LoggingInfo::property_page_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return property_page_info_ != NULL ? *property_page_info_ : *default_instance().property_page_info_;
#else
  return property_page_info_ != NULL ? *property_page_info_ : *default_instance_->property_page_info_;
#endif
}
inline ::net_instaweb::PropertyPageInfo* LoggingInfo::mutable_property_page_info() {
  set_has_property_page_info();
  if (property_page_info_ == NULL) property_page_info_ = new ::net_instaweb::PropertyPageInfo;
  return property_page_info_;
}
inline ::net_instaweb::PropertyPageInfo* LoggingInfo::release_property_page_info() {
  clear_has_property_page_info();
  ::net_instaweb::PropertyPageInfo* temp = property_page_info_;
  property_page_info_ = NULL;
  return temp;
}

// repeated .net_instaweb.RewriterInfo rewriter_info = 9;
inline int LoggingInfo::rewriter_info_size() const {
  return rewriter_info_.size();
}
inline void LoggingInfo::clear_rewriter_info() {
  rewriter_info_.Clear();
}
inline const ::net_instaweb::RewriterInfo& LoggingInfo::rewriter_info(int index) const {
  return rewriter_info_.Get(index);
}
inline ::net_instaweb::RewriterInfo* LoggingInfo::mutable_rewriter_info(int index) {
  return rewriter_info_.Mutable(index);
}
inline ::net_instaweb::RewriterInfo* LoggingInfo::add_rewriter_info() {
  return rewriter_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriterInfo >&
LoggingInfo::rewriter_info() const {
  return rewriter_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriterInfo >*
LoggingInfo::mutable_rewriter_info() {
  return &rewriter_info_;
}

// repeated .net_instaweb.RewriterStats rewriter_stats = 22;
inline int LoggingInfo::rewriter_stats_size() const {
  return rewriter_stats_.size();
}
inline void LoggingInfo::clear_rewriter_stats() {
  rewriter_stats_.Clear();
}
inline const ::net_instaweb::RewriterStats& LoggingInfo::rewriter_stats(int index) const {
  return rewriter_stats_.Get(index);
}
inline ::net_instaweb::RewriterStats* LoggingInfo::mutable_rewriter_stats(int index) {
  return rewriter_stats_.Mutable(index);
}
inline ::net_instaweb::RewriterStats* LoggingInfo::add_rewriter_stats() {
  return rewriter_stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriterStats >&
LoggingInfo::rewriter_stats() const {
  return rewriter_stats_;
}
inline ::google::protobuf::RepeatedPtrField< ::net_instaweb::RewriterStats >*
LoggingInfo::mutable_rewriter_stats() {
  return &rewriter_stats_;
}

// optional bool is_html_response = 10 [default = false];
inline bool LoggingInfo::has_is_html_response() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoggingInfo::set_has_is_html_response() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoggingInfo::clear_has_is_html_response() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoggingInfo::clear_is_html_response() {
  is_html_response_ = false;
  clear_has_is_html_response();
}
inline bool LoggingInfo::is_html_response() const {
  return is_html_response_;
}
inline void LoggingInfo::set_is_html_response(bool value) {
  set_has_is_html_response();
  is_html_response_ = value;
}

// optional bool is_url_disallowed = 11 [default = false];
inline bool LoggingInfo::has_is_url_disallowed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LoggingInfo::set_has_is_url_disallowed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LoggingInfo::clear_has_is_url_disallowed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LoggingInfo::clear_is_url_disallowed() {
  is_url_disallowed_ = false;
  clear_has_is_url_disallowed();
}
inline bool LoggingInfo::is_url_disallowed() const {
  return is_url_disallowed_;
}
inline void LoggingInfo::set_is_url_disallowed(bool value) {
  set_has_is_url_disallowed();
  is_url_disallowed_ = value;
}

// optional int64 options_signature_hash = 12;
inline bool LoggingInfo::has_options_signature_hash() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LoggingInfo::set_has_options_signature_hash() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LoggingInfo::clear_has_options_signature_hash() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LoggingInfo::clear_options_signature_hash() {
  options_signature_hash_ = GOOGLE_LONGLONG(0);
  clear_has_options_signature_hash();
}
inline ::google::protobuf::int64 LoggingInfo::options_signature_hash() const {
  return options_signature_hash_;
}
inline void LoggingInfo::set_options_signature_hash(::google::protobuf::int64 value) {
  set_has_options_signature_hash();
  options_signature_hash_ = value;
}

// optional bool is_request_disabled = 13 [default = false];
inline bool LoggingInfo::has_is_request_disabled() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LoggingInfo::set_has_is_request_disabled() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LoggingInfo::clear_has_is_request_disabled() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LoggingInfo::clear_is_request_disabled() {
  is_request_disabled_ = false;
  clear_has_is_request_disabled();
}
inline bool LoggingInfo::is_request_disabled() const {
  return is_request_disabled_;
}
inline void LoggingInfo::set_is_request_disabled(bool value) {
  set_has_is_request_disabled();
  is_request_disabled_ = value;
}

// optional .net_instaweb.FlushEarlyFlowInfo flush_early_flow_info = 14;
inline bool LoggingInfo::has_flush_early_flow_info() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LoggingInfo::set_has_flush_early_flow_info() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LoggingInfo::clear_has_flush_early_flow_info() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LoggingInfo::clear_flush_early_flow_info() {
  if (flush_early_flow_info_ != NULL) flush_early_flow_info_->::net_instaweb::FlushEarlyFlowInfo::Clear();
  clear_has_flush_early_flow_info();
}
inline const ::net_instaweb::FlushEarlyFlowInfo& LoggingInfo::flush_early_flow_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return flush_early_flow_info_ != NULL ? *flush_early_flow_info_ : *default_instance().flush_early_flow_info_;
#else
  return flush_early_flow_info_ != NULL ? *flush_early_flow_info_ : *default_instance_->flush_early_flow_info_;
#endif
}
inline ::net_instaweb::FlushEarlyFlowInfo* LoggingInfo::mutable_flush_early_flow_info() {
  set_has_flush_early_flow_info();
  if (flush_early_flow_info_ == NULL) flush_early_flow_info_ = new ::net_instaweb::FlushEarlyFlowInfo;
  return flush_early_flow_info_;
}
inline ::net_instaweb::FlushEarlyFlowInfo* LoggingInfo::release_flush_early_flow_info() {
  clear_has_flush_early_flow_info();
  ::net_instaweb::FlushEarlyFlowInfo* temp = flush_early_flow_info_;
  flush_early_flow_info_ = NULL;
  return temp;
}

// optional bool rewriter_info_size_limit_exceeded = 15 [default = false];
inline bool LoggingInfo::has_rewriter_info_size_limit_exceeded() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LoggingInfo::set_has_rewriter_info_size_limit_exceeded() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LoggingInfo::clear_has_rewriter_info_size_limit_exceeded() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LoggingInfo::clear_rewriter_info_size_limit_exceeded() {
  rewriter_info_size_limit_exceeded_ = false;
  clear_has_rewriter_info_size_limit_exceeded();
}
inline bool LoggingInfo::rewriter_info_size_limit_exceeded() const {
  return rewriter_info_size_limit_exceeded_;
}
inline void LoggingInfo::set_rewriter_info_size_limit_exceeded(bool value) {
  set_has_rewriter_info_size_limit_exceeded();
  rewriter_info_size_limit_exceeded_ = value;
}

// optional bool is_pagespeed_resource = 16 [default = false];
inline bool LoggingInfo::has_is_pagespeed_resource() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LoggingInfo::set_has_is_pagespeed_resource() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LoggingInfo::clear_has_is_pagespeed_resource() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LoggingInfo::clear_is_pagespeed_resource() {
  is_pagespeed_resource_ = false;
  clear_has_is_pagespeed_resource();
}
inline bool LoggingInfo::is_pagespeed_resource() const {
  return is_pagespeed_resource_;
}
inline void LoggingInfo::set_is_pagespeed_resource(bool value) {
  set_has_is_pagespeed_resource();
  is_pagespeed_resource_ = value;
}

// optional .net_instaweb.ResourceUrlInfo resource_url_info = 17;
inline bool LoggingInfo::has_resource_url_info() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LoggingInfo::set_has_resource_url_info() {
  _has_bits_[0] |= 0x00020000u;
}
inline void LoggingInfo::clear_has_resource_url_info() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void LoggingInfo::clear_resource_url_info() {
  if (resource_url_info_ != NULL) resource_url_info_->::net_instaweb::ResourceUrlInfo::Clear();
  clear_has_resource_url_info();
}
inline const ::net_instaweb::ResourceUrlInfo& LoggingInfo::resource_url_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return resource_url_info_ != NULL ? *resource_url_info_ : *default_instance().resource_url_info_;
#else
  return resource_url_info_ != NULL ? *resource_url_info_ : *default_instance_->resource_url_info_;
#endif
}
inline ::net_instaweb::ResourceUrlInfo* LoggingInfo::mutable_resource_url_info() {
  set_has_resource_url_info();
  if (resource_url_info_ == NULL) resource_url_info_ = new ::net_instaweb::ResourceUrlInfo;
  return resource_url_info_;
}
inline ::net_instaweb::ResourceUrlInfo* LoggingInfo::release_resource_url_info() {
  clear_has_resource_url_info();
  ::net_instaweb::ResourceUrlInfo* temp = resource_url_info_;
  resource_url_info_ = NULL;
  return temp;
}

// optional .net_instaweb.CacheHtmlLoggingInfo cache_html_logging_info = 18;
inline bool LoggingInfo::has_cache_html_logging_info() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LoggingInfo::set_has_cache_html_logging_info() {
  _has_bits_[0] |= 0x00040000u;
}
inline void LoggingInfo::clear_has_cache_html_logging_info() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void LoggingInfo::clear_cache_html_logging_info() {
  if (cache_html_logging_info_ != NULL) cache_html_logging_info_->::net_instaweb::CacheHtmlLoggingInfo::Clear();
  clear_has_cache_html_logging_info();
}
inline const ::net_instaweb::CacheHtmlLoggingInfo& LoggingInfo::cache_html_logging_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cache_html_logging_info_ != NULL ? *cache_html_logging_info_ : *default_instance().cache_html_logging_info_;
#else
  return cache_html_logging_info_ != NULL ? *cache_html_logging_info_ : *default_instance_->cache_html_logging_info_;
#endif
}
inline ::net_instaweb::CacheHtmlLoggingInfo* LoggingInfo::mutable_cache_html_logging_info() {
  set_has_cache_html_logging_info();
  if (cache_html_logging_info_ == NULL) cache_html_logging_info_ = new ::net_instaweb::CacheHtmlLoggingInfo;
  return cache_html_logging_info_;
}
inline ::net_instaweb::CacheHtmlLoggingInfo* LoggingInfo::release_cache_html_logging_info() {
  clear_has_cache_html_logging_info();
  ::net_instaweb::CacheHtmlLoggingInfo* temp = cache_html_logging_info_;
  cache_html_logging_info_ = NULL;
  return temp;
}

// optional int32 num_html_critical_images = 19 [default = -1];
inline bool LoggingInfo::has_num_html_critical_images() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void LoggingInfo::set_has_num_html_critical_images() {
  _has_bits_[0] |= 0x00080000u;
}
inline void LoggingInfo::clear_has_num_html_critical_images() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void LoggingInfo::clear_num_html_critical_images() {
  num_html_critical_images_ = -1;
  clear_has_num_html_critical_images();
}
inline ::google::protobuf::int32 LoggingInfo::num_html_critical_images() const {
  return num_html_critical_images_;
}
inline void LoggingInfo::set_num_html_critical_images(::google::protobuf::int32 value) {
  set_has_num_html_critical_images();
  num_html_critical_images_ = value;
}

// optional int32 num_css_critical_images = 20 [default = -1];
inline bool LoggingInfo::has_num_css_critical_images() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void LoggingInfo::set_has_num_css_critical_images() {
  _has_bits_[0] |= 0x00100000u;
}
inline void LoggingInfo::clear_has_num_css_critical_images() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void LoggingInfo::clear_num_css_critical_images() {
  num_css_critical_images_ = -1;
  clear_has_num_css_critical_images();
}
inline ::google::protobuf::int32 LoggingInfo::num_css_critical_images() const {
  return num_css_critical_images_;
}
inline void LoggingInfo::set_num_css_critical_images(::google::protobuf::int32 value) {
  set_has_num_css_critical_images();
  num_css_critical_images_ = value;
}

// optional .net_instaweb.ImageStats image_stats = 21;
inline bool LoggingInfo::has_image_stats() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void LoggingInfo::set_has_image_stats() {
  _has_bits_[0] |= 0x00200000u;
}
inline void LoggingInfo::clear_has_image_stats() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void LoggingInfo::clear_image_stats() {
  if (image_stats_ != NULL) image_stats_->::net_instaweb::ImageStats::Clear();
  clear_has_image_stats();
}
inline const ::net_instaweb::ImageStats& LoggingInfo::image_stats() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return image_stats_ != NULL ? *image_stats_ : *default_instance().image_stats_;
#else
  return image_stats_ != NULL ? *image_stats_ : *default_instance_->image_stats_;
#endif
}
inline ::net_instaweb::ImageStats* LoggingInfo::mutable_image_stats() {
  set_has_image_stats();
  if (image_stats_ == NULL) image_stats_ = new ::net_instaweb::ImageStats;
  return image_stats_;
}
inline ::net_instaweb::ImageStats* LoggingInfo::release_image_stats() {
  clear_has_image_stats();
  ::net_instaweb::ImageStats* temp = image_stats_;
  image_stats_ = NULL;
  return temp;
}

// optional .net_instaweb.CriticalCssInfo critical_css_info = 23;
inline bool LoggingInfo::has_critical_css_info() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void LoggingInfo::set_has_critical_css_info() {
  _has_bits_[0] |= 0x00400000u;
}
inline void LoggingInfo::clear_has_critical_css_info() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void LoggingInfo::clear_critical_css_info() {
  if (critical_css_info_ != NULL) critical_css_info_->::net_instaweb::CriticalCssInfo::Clear();
  clear_has_critical_css_info();
}
inline const ::net_instaweb::CriticalCssInfo& LoggingInfo::critical_css_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return critical_css_info_ != NULL ? *critical_css_info_ : *default_instance().critical_css_info_;
#else
  return critical_css_info_ != NULL ? *critical_css_info_ : *default_instance_->critical_css_info_;
#endif
}
inline ::net_instaweb::CriticalCssInfo* LoggingInfo::mutable_critical_css_info() {
  set_has_critical_css_info();
  if (critical_css_info_ == NULL) critical_css_info_ = new ::net_instaweb::CriticalCssInfo;
  return critical_css_info_;
}
inline ::net_instaweb::CriticalCssInfo* LoggingInfo::release_critical_css_info() {
  clear_has_critical_css_info();
  ::net_instaweb::CriticalCssInfo* temp = critical_css_info_;
  critical_css_info_ = NULL;
  return temp;
}

// optional .net_instaweb.DeviceInfo device_info = 24;
inline bool LoggingInfo::has_device_info() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void LoggingInfo::set_has_device_info() {
  _has_bits_[0] |= 0x00800000u;
}
inline void LoggingInfo::clear_has_device_info() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void LoggingInfo::clear_device_info() {
  if (device_info_ != NULL) device_info_->::net_instaweb::DeviceInfo::Clear();
  clear_has_device_info();
}
inline const ::net_instaweb::DeviceInfo& LoggingInfo::device_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_info_ != NULL ? *device_info_ : *default_instance().device_info_;
#else
  return device_info_ != NULL ? *device_info_ : *default_instance_->device_info_;
#endif
}
inline ::net_instaweb::DeviceInfo* LoggingInfo::mutable_device_info() {
  set_has_device_info();
  if (device_info_ == NULL) device_info_ = new ::net_instaweb::DeviceInfo;
  return device_info_;
}
inline ::net_instaweb::DeviceInfo* LoggingInfo::release_device_info() {
  clear_has_device_info();
  ::net_instaweb::DeviceInfo* temp = device_info_;
  device_info_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace net_instaweb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_net_2finstaweb_2fhttp_2flogging_2eproto__INCLUDED
