// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net/instaweb/rewriter/cached_result.proto

#ifndef PROTOBUF_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto__INCLUDED
#define PROTOBUF_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "net/instaweb/spriter/public/image_spriter.pb.h"
// @@protoc_insertion_point(includes)

namespace net_instaweb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
void protobuf_AssignDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
void protobuf_ShutdownFile_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();

class ImageDim;
class InputInfo;
class CachedResult;
class OutputPartitions;
class ResourceContext;

enum InputInfo_Type {
  InputInfo_Type_CACHED = 1,
  InputInfo_Type_FILE_BASED = 2,
  InputInfo_Type_ALWAYS_VALID = 3
};
bool InputInfo_Type_IsValid(int value);
const InputInfo_Type InputInfo_Type_Type_MIN = InputInfo_Type_CACHED;
const InputInfo_Type InputInfo_Type_Type_MAX = InputInfo_Type_ALWAYS_VALID;
const int InputInfo_Type_Type_ARRAYSIZE = InputInfo_Type_Type_MAX + 1;

enum ResourceContext_LibWebpLevel {
  ResourceContext_LibWebpLevel_LIBWEBP_NONE = 0,
  ResourceContext_LibWebpLevel_LIBWEBP_LOSSY_ONLY = 1,
  ResourceContext_LibWebpLevel_LIBWEBP_LOSSY_LOSSLESS_ALPHA = 2
};
bool ResourceContext_LibWebpLevel_IsValid(int value);
const ResourceContext_LibWebpLevel ResourceContext_LibWebpLevel_LibWebpLevel_MIN = ResourceContext_LibWebpLevel_LIBWEBP_NONE;
const ResourceContext_LibWebpLevel ResourceContext_LibWebpLevel_LibWebpLevel_MAX = ResourceContext_LibWebpLevel_LIBWEBP_LOSSY_LOSSLESS_ALPHA;
const int ResourceContext_LibWebpLevel_LibWebpLevel_ARRAYSIZE = ResourceContext_LibWebpLevel_LibWebpLevel_MAX + 1;

// ===================================================================

class ImageDim : public ::google::protobuf::MessageLite {
 public:
  ImageDim();
  virtual ~ImageDim();
  
  ImageDim(const ImageDim& from);
  
  inline ImageDim& operator=(const ImageDim& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ImageDim& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ImageDim* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(ImageDim* other);
  
  // implements Message ----------------------------------------------
  
  ImageDim* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ImageDim& from);
  void MergeFrom(const ImageDim& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 width = 1 [default = -1];
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // optional int32 height = 2 [default = -1];
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.ImageDim)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  
  void InitAsDefaultInstance();
  static ImageDim* default_instance_;
};
// -------------------------------------------------------------------

class InputInfo : public ::google::protobuf::MessageLite {
 public:
  InputInfo();
  virtual ~InputInfo();
  
  InputInfo(const InputInfo& from);
  
  inline InputInfo& operator=(const InputInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const InputInfo& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InputInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(InputInfo* other);
  
  // implements Message ----------------------------------------------
  
  InputInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InputInfo& from);
  void MergeFrom(const InputInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef InputInfo_Type Type;
  static const Type CACHED = InputInfo_Type_CACHED;
  static const Type FILE_BASED = InputInfo_Type_FILE_BASED;
  static const Type ALWAYS_VALID = InputInfo_Type_ALWAYS_VALID;
  static inline bool Type_IsValid(int value) {
    return InputInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    InputInfo_Type_Type_MIN;
  static const Type Type_MAX =
    InputInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    InputInfo_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);
  
  // required .net_instaweb.InputInfo.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::net_instaweb::InputInfo_Type type() const;
  inline void set_type(::net_instaweb::InputInfo_Type value);
  
  // optional int64 last_modified_time_ms = 3;
  inline bool has_last_modified_time_ms() const;
  inline void clear_last_modified_time_ms();
  static const int kLastModifiedTimeMsFieldNumber = 3;
  inline ::google::protobuf::int64 last_modified_time_ms() const;
  inline void set_last_modified_time_ms(::google::protobuf::int64 value);
  
  // optional int64 expiration_time_ms = 4;
  inline bool has_expiration_time_ms() const;
  inline void clear_expiration_time_ms();
  static const int kExpirationTimeMsFieldNumber = 4;
  inline ::google::protobuf::int64 expiration_time_ms() const;
  inline void set_expiration_time_ms(::google::protobuf::int64 value);
  
  // optional int64 date_ms = 6;
  inline bool has_date_ms() const;
  inline void clear_date_ms();
  static const int kDateMsFieldNumber = 6;
  inline ::google::protobuf::int64 date_ms() const;
  inline void set_date_ms(::google::protobuf::int64 value);
  
  // optional string input_content_hash = 7;
  inline bool has_input_content_hash() const;
  inline void clear_input_content_hash();
  static const int kInputContentHashFieldNumber = 7;
  inline const ::std::string& input_content_hash() const;
  inline void set_input_content_hash(const ::std::string& value);
  inline void set_input_content_hash(const char* value);
  inline void set_input_content_hash(const char* value, size_t size);
  inline ::std::string* mutable_input_content_hash();
  inline ::std::string* release_input_content_hash();
  
  // optional string filename = 5;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 5;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  
  // optional bool disable_further_processing = 8 [default = false];
  inline bool has_disable_further_processing() const;
  inline void clear_disable_further_processing();
  static const int kDisableFurtherProcessingFieldNumber = 8;
  inline bool disable_further_processing() const;
  inline void set_disable_further_processing(bool value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.InputInfo)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_last_modified_time_ms();
  inline void clear_has_last_modified_time_ms();
  inline void set_has_expiration_time_ms();
  inline void clear_has_expiration_time_ms();
  inline void set_has_date_ms();
  inline void clear_has_date_ms();
  inline void set_has_input_content_hash();
  inline void clear_has_input_content_hash();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_disable_further_processing();
  inline void clear_has_disable_further_processing();
  
  ::google::protobuf::int32 index_;
  int type_;
  ::google::protobuf::int64 last_modified_time_ms_;
  ::google::protobuf::int64 expiration_time_ms_;
  ::google::protobuf::int64 date_ms_;
  ::std::string* input_content_hash_;
  ::std::string* filename_;
  bool disable_further_processing_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  
  void InitAsDefaultInstance();
  static InputInfo* default_instance_;
};
// -------------------------------------------------------------------

class CachedResult : public ::google::protobuf::MessageLite {
 public:
  CachedResult();
  virtual ~CachedResult();
  
  CachedResult(const CachedResult& from);
  
  inline CachedResult& operator=(const CachedResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CachedResult& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CachedResult* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(CachedResult* other);
  
  // implements Message ----------------------------------------------
  
  CachedResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CachedResult& from);
  void MergeFrom(const CachedResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool optimizable = 1 [default = true];
  inline bool has_optimizable() const;
  inline void clear_optimizable();
  static const int kOptimizableFieldNumber = 1;
  inline bool optimizable() const;
  inline void set_optimizable(bool value);
  
  // optional string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // optional bool frozen = 5 [default = false];
  inline bool has_frozen() const;
  inline void clear_frozen();
  static const int kFrozenFieldNumber = 5;
  inline bool frozen() const;
  inline void set_frozen(bool value);
  
  // optional string hash = 6;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 6;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const char* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  
  // optional string extension = 7;
  inline bool has_extension() const;
  inline void clear_extension();
  static const int kExtensionFieldNumber = 7;
  inline const ::std::string& extension() const;
  inline void set_extension(const ::std::string& value);
  inline void set_extension(const char* value);
  inline void set_extension(const char* value, size_t size);
  inline ::std::string* mutable_extension();
  inline ::std::string* release_extension();
  
  // optional .net_instaweb.ImageDim image_file_dims = 11;
  inline bool has_image_file_dims() const;
  inline void clear_image_file_dims();
  static const int kImageFileDimsFieldNumber = 11;
  inline const ::net_instaweb::ImageDim& image_file_dims() const;
  inline ::net_instaweb::ImageDim* mutable_image_file_dims();
  inline ::net_instaweb::ImageDim* release_image_file_dims();
  
  // optional bytes inlined_data = 12;
  inline bool has_inlined_data() const;
  inline void clear_inlined_data();
  static const int kInlinedDataFieldNumber = 12;
  inline const ::std::string& inlined_data() const;
  inline void set_inlined_data(const ::std::string& value);
  inline void set_inlined_data(const char* value);
  inline void set_inlined_data(const void* value, size_t size);
  inline ::std::string* mutable_inlined_data();
  inline ::std::string* release_inlined_data();
  
  // optional .net_instaweb.spriter.SpriterResult spriter_result = 13;
  inline bool has_spriter_result() const;
  inline void clear_spriter_result();
  static const int kSpriterResultFieldNumber = 13;
  inline const ::net_instaweb::spriter::SpriterResult& spriter_result() const;
  inline ::net_instaweb::spriter::SpriterResult* mutable_spriter_result();
  inline ::net_instaweb::spriter::SpriterResult* release_spriter_result();
  
  // repeated .net_instaweb.InputInfo input = 14;
  inline int input_size() const;
  inline void clear_input();
  static const int kInputFieldNumber = 14;
  inline const ::net_instaweb::InputInfo& input(int index) const;
  inline ::net_instaweb::InputInfo* mutable_input(int index);
  inline ::net_instaweb::InputInfo* add_input();
  inline const ::google::protobuf::RepeatedPtrField< ::net_instaweb::InputInfo >&
      input() const;
  inline ::google::protobuf::RepeatedPtrField< ::net_instaweb::InputInfo >*
      mutable_input();
  
  // optional int32 inlined_image_type = 15;
  inline bool has_inlined_image_type() const;
  inline void clear_inlined_image_type();
  static const int kInlinedImageTypeFieldNumber = 15;
  inline ::google::protobuf::int32 inlined_image_type() const;
  inline void set_inlined_image_type(::google::protobuf::int32 value);
  
  // optional bytes low_resolution_inlined_data = 16;
  inline bool has_low_resolution_inlined_data() const;
  inline void clear_low_resolution_inlined_data();
  static const int kLowResolutionInlinedDataFieldNumber = 16;
  inline const ::std::string& low_resolution_inlined_data() const;
  inline void set_low_resolution_inlined_data(const ::std::string& value);
  inline void set_low_resolution_inlined_data(const char* value);
  inline void set_low_resolution_inlined_data(const void* value, size_t size);
  inline ::std::string* mutable_low_resolution_inlined_data();
  inline ::std::string* release_low_resolution_inlined_data();
  
  // optional int32 low_resolution_inlined_image_type = 17;
  inline bool has_low_resolution_inlined_image_type() const;
  inline void clear_low_resolution_inlined_image_type();
  static const int kLowResolutionInlinedImageTypeFieldNumber = 17;
  inline ::google::protobuf::int32 low_resolution_inlined_image_type() const;
  inline void set_low_resolution_inlined_image_type(::google::protobuf::int32 value);
  
  // optional bool url_relocatable = 18 [default = true];
  inline bool has_url_relocatable() const;
  inline void clear_url_relocatable();
  static const int kUrlRelocatableFieldNumber = 18;
  inline bool url_relocatable() const;
  inline void set_url_relocatable(bool value);
  
  // optional bool canonicalize_url = 19 [default = false];
  inline bool has_canonicalize_url() const;
  inline void clear_canonicalize_url();
  static const int kCanonicalizeUrlFieldNumber = 19;
  inline bool canonicalize_url() const;
  inline void set_canonicalize_url(bool value);
  
  // optional int64 size = 20;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 20;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.CachedResult)
 private:
  inline void set_has_optimizable();
  inline void clear_has_optimizable();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_frozen();
  inline void clear_has_frozen();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_extension();
  inline void clear_has_extension();
  inline void set_has_image_file_dims();
  inline void clear_has_image_file_dims();
  inline void set_has_inlined_data();
  inline void clear_has_inlined_data();
  inline void set_has_spriter_result();
  inline void clear_has_spriter_result();
  inline void set_has_inlined_image_type();
  inline void clear_has_inlined_image_type();
  inline void set_has_low_resolution_inlined_data();
  inline void clear_has_low_resolution_inlined_data();
  inline void set_has_low_resolution_inlined_image_type();
  inline void clear_has_low_resolution_inlined_image_type();
  inline void set_has_url_relocatable();
  inline void clear_has_url_relocatable();
  inline void set_has_canonicalize_url();
  inline void clear_has_canonicalize_url();
  inline void set_has_size();
  inline void clear_has_size();
  
  ::std::string* url_;
  ::std::string* hash_;
  ::std::string* extension_;
  ::net_instaweb::ImageDim* image_file_dims_;
  ::std::string* inlined_data_;
  ::net_instaweb::spriter::SpriterResult* spriter_result_;
  bool optimizable_;
  bool frozen_;
  bool url_relocatable_;
  bool canonicalize_url_;
  ::google::protobuf::int32 inlined_image_type_;
  ::google::protobuf::RepeatedPtrField< ::net_instaweb::InputInfo > input_;
  ::std::string* low_resolution_inlined_data_;
  ::google::protobuf::int64 size_;
  ::google::protobuf::int32 low_resolution_inlined_image_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  
  void InitAsDefaultInstance();
  static CachedResult* default_instance_;
};
// -------------------------------------------------------------------

class OutputPartitions : public ::google::protobuf::MessageLite {
 public:
  OutputPartitions();
  virtual ~OutputPartitions();
  
  OutputPartitions(const OutputPartitions& from);
  
  inline OutputPartitions& operator=(const OutputPartitions& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const OutputPartitions& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OutputPartitions* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(OutputPartitions* other);
  
  // implements Message ----------------------------------------------
  
  OutputPartitions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OutputPartitions& from);
  void MergeFrom(const OutputPartitions& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .net_instaweb.CachedResult partition = 1;
  inline int partition_size() const;
  inline void clear_partition();
  static const int kPartitionFieldNumber = 1;
  inline const ::net_instaweb::CachedResult& partition(int index) const;
  inline ::net_instaweb::CachedResult* mutable_partition(int index);
  inline ::net_instaweb::CachedResult* add_partition();
  inline const ::google::protobuf::RepeatedPtrField< ::net_instaweb::CachedResult >&
      partition() const;
  inline ::google::protobuf::RepeatedPtrField< ::net_instaweb::CachedResult >*
      mutable_partition();
  
  // repeated .net_instaweb.InputInfo other_dependency = 2;
  inline int other_dependency_size() const;
  inline void clear_other_dependency();
  static const int kOtherDependencyFieldNumber = 2;
  inline const ::net_instaweb::InputInfo& other_dependency(int index) const;
  inline ::net_instaweb::InputInfo* mutable_other_dependency(int index);
  inline ::net_instaweb::InputInfo* add_other_dependency();
  inline const ::google::protobuf::RepeatedPtrField< ::net_instaweb::InputInfo >&
      other_dependency() const;
  inline ::google::protobuf::RepeatedPtrField< ::net_instaweb::InputInfo >*
      mutable_other_dependency();
  
  // @@protoc_insertion_point(class_scope:net_instaweb.OutputPartitions)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::net_instaweb::CachedResult > partition_;
  ::google::protobuf::RepeatedPtrField< ::net_instaweb::InputInfo > other_dependency_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  
  void InitAsDefaultInstance();
  static OutputPartitions* default_instance_;
};
// -------------------------------------------------------------------

class ResourceContext : public ::google::protobuf::MessageLite {
 public:
  ResourceContext();
  virtual ~ResourceContext();
  
  ResourceContext(const ResourceContext& from);
  
  inline ResourceContext& operator=(const ResourceContext& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ResourceContext& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResourceContext* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(ResourceContext* other);
  
  // implements Message ----------------------------------------------
  
  ResourceContext* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResourceContext& from);
  void MergeFrom(const ResourceContext& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ResourceContext_LibWebpLevel LibWebpLevel;
  static const LibWebpLevel LIBWEBP_NONE = ResourceContext_LibWebpLevel_LIBWEBP_NONE;
  static const LibWebpLevel LIBWEBP_LOSSY_ONLY = ResourceContext_LibWebpLevel_LIBWEBP_LOSSY_ONLY;
  static const LibWebpLevel LIBWEBP_LOSSY_LOSSLESS_ALPHA = ResourceContext_LibWebpLevel_LIBWEBP_LOSSY_LOSSLESS_ALPHA;
  static inline bool LibWebpLevel_IsValid(int value) {
    return ResourceContext_LibWebpLevel_IsValid(value);
  }
  static const LibWebpLevel LibWebpLevel_MIN =
    ResourceContext_LibWebpLevel_LibWebpLevel_MIN;
  static const LibWebpLevel LibWebpLevel_MAX =
    ResourceContext_LibWebpLevel_LibWebpLevel_MAX;
  static const int LibWebpLevel_ARRAYSIZE =
    ResourceContext_LibWebpLevel_LibWebpLevel_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional .net_instaweb.ImageDim desired_image_dims = 1;
  inline bool has_desired_image_dims() const;
  inline void clear_desired_image_dims();
  static const int kDesiredImageDimsFieldNumber = 1;
  inline const ::net_instaweb::ImageDim& desired_image_dims() const;
  inline ::net_instaweb::ImageDim* mutable_desired_image_dims();
  inline ::net_instaweb::ImageDim* release_desired_image_dims();
  
  // optional bool attempt_webp = 2 [default = false, deprecated = true];
  inline bool has_attempt_webp() const PROTOBUF_DEPRECATED;
  inline void clear_attempt_webp() PROTOBUF_DEPRECATED;
  static const int kAttemptWebpFieldNumber = 2;
  inline bool attempt_webp() const PROTOBUF_DEPRECATED;
  inline void set_attempt_webp(bool value) PROTOBUF_DEPRECATED;
  
  // optional bool inline_images = 3 [default = true];
  inline bool has_inline_images() const;
  inline void clear_inline_images();
  static const int kInlineImagesFieldNumber = 3;
  inline bool inline_images() const;
  inline void set_inline_images(bool value);
  
  // optional bool mobile_user_agent = 4 [default = false];
  inline bool has_mobile_user_agent() const;
  inline void clear_mobile_user_agent();
  static const int kMobileUserAgentFieldNumber = 4;
  inline bool mobile_user_agent() const;
  inline void set_mobile_user_agent(bool value);
  
  // optional .net_instaweb.ResourceContext.LibWebpLevel libwebp_level = 5 [default = LIBWEBP_NONE];
  inline bool has_libwebp_level() const;
  inline void clear_libwebp_level();
  static const int kLibwebpLevelFieldNumber = 5;
  inline ::net_instaweb::ResourceContext_LibWebpLevel libwebp_level() const;
  inline void set_libwebp_level(::net_instaweb::ResourceContext_LibWebpLevel value);
  
  // optional .net_instaweb.ImageDim user_agent_screen_resolution = 6;
  inline bool has_user_agent_screen_resolution() const;
  inline void clear_user_agent_screen_resolution();
  static const int kUserAgentScreenResolutionFieldNumber = 6;
  inline const ::net_instaweb::ImageDim& user_agent_screen_resolution() const;
  inline ::net_instaweb::ImageDim* mutable_user_agent_screen_resolution();
  inline ::net_instaweb::ImageDim* release_user_agent_screen_resolution();
  
  // optional bool use_small_screen_quality = 7 [default = false];
  inline bool has_use_small_screen_quality() const;
  inline void clear_use_small_screen_quality();
  static const int kUseSmallScreenQualityFieldNumber = 7;
  inline bool use_small_screen_quality() const;
  inline void set_use_small_screen_quality(bool value);
  
  // @@protoc_insertion_point(class_scope:net_instaweb.ResourceContext)
 private:
  inline void set_has_desired_image_dims();
  inline void clear_has_desired_image_dims();
  inline void set_has_attempt_webp();
  inline void clear_has_attempt_webp();
  inline void set_has_inline_images();
  inline void clear_has_inline_images();
  inline void set_has_mobile_user_agent();
  inline void clear_has_mobile_user_agent();
  inline void set_has_libwebp_level();
  inline void clear_has_libwebp_level();
  inline void set_has_user_agent_screen_resolution();
  inline void clear_has_user_agent_screen_resolution();
  inline void set_has_use_small_screen_quality();
  inline void clear_has_use_small_screen_quality();
  
  ::net_instaweb::ImageDim* desired_image_dims_;
  bool attempt_webp_;
  bool inline_images_;
  bool mobile_user_agent_;
  bool use_small_screen_quality_;
  int libwebp_level_;
  ::net_instaweb::ImageDim* user_agent_screen_resolution_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  #endif
  friend void protobuf_AssignDesc_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  friend void protobuf_ShutdownFile_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto();
  
  void InitAsDefaultInstance();
  static ResourceContext* default_instance_;
};
// ===================================================================


// ===================================================================

// ImageDim

// optional int32 width = 1 [default = -1];
inline bool ImageDim::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageDim::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageDim::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageDim::clear_width() {
  width_ = -1;
  clear_has_width();
}
inline ::google::protobuf::int32 ImageDim::width() const {
  return width_;
}
inline void ImageDim::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int32 height = 2 [default = -1];
inline bool ImageDim::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageDim::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageDim::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageDim::clear_height() {
  height_ = -1;
  clear_has_height();
}
inline ::google::protobuf::int32 ImageDim::height() const {
  return height_;
}
inline void ImageDim::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// InputInfo

// optional int32 index = 1;
inline bool InputInfo::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputInfo::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InputInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InputInfo::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 InputInfo::index() const {
  return index_;
}
inline void InputInfo::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// required .net_instaweb.InputInfo.Type type = 2;
inline bool InputInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InputInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InputInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::net_instaweb::InputInfo_Type InputInfo::type() const {
  return static_cast< ::net_instaweb::InputInfo_Type >(type_);
}
inline void InputInfo::set_type(::net_instaweb::InputInfo_Type value) {
  GOOGLE_DCHECK(::net_instaweb::InputInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int64 last_modified_time_ms = 3;
inline bool InputInfo::has_last_modified_time_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InputInfo::set_has_last_modified_time_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InputInfo::clear_has_last_modified_time_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InputInfo::clear_last_modified_time_ms() {
  last_modified_time_ms_ = GOOGLE_LONGLONG(0);
  clear_has_last_modified_time_ms();
}
inline ::google::protobuf::int64 InputInfo::last_modified_time_ms() const {
  return last_modified_time_ms_;
}
inline void InputInfo::set_last_modified_time_ms(::google::protobuf::int64 value) {
  set_has_last_modified_time_ms();
  last_modified_time_ms_ = value;
}

// optional int64 expiration_time_ms = 4;
inline bool InputInfo::has_expiration_time_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InputInfo::set_has_expiration_time_ms() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InputInfo::clear_has_expiration_time_ms() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InputInfo::clear_expiration_time_ms() {
  expiration_time_ms_ = GOOGLE_LONGLONG(0);
  clear_has_expiration_time_ms();
}
inline ::google::protobuf::int64 InputInfo::expiration_time_ms() const {
  return expiration_time_ms_;
}
inline void InputInfo::set_expiration_time_ms(::google::protobuf::int64 value) {
  set_has_expiration_time_ms();
  expiration_time_ms_ = value;
}

// optional int64 date_ms = 6;
inline bool InputInfo::has_date_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InputInfo::set_has_date_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InputInfo::clear_has_date_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InputInfo::clear_date_ms() {
  date_ms_ = GOOGLE_LONGLONG(0);
  clear_has_date_ms();
}
inline ::google::protobuf::int64 InputInfo::date_ms() const {
  return date_ms_;
}
inline void InputInfo::set_date_ms(::google::protobuf::int64 value) {
  set_has_date_ms();
  date_ms_ = value;
}

// optional string input_content_hash = 7;
inline bool InputInfo::has_input_content_hash() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InputInfo::set_has_input_content_hash() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InputInfo::clear_has_input_content_hash() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InputInfo::clear_input_content_hash() {
  if (input_content_hash_ != &::google::protobuf::internal::kEmptyString) {
    input_content_hash_->clear();
  }
  clear_has_input_content_hash();
}
inline const ::std::string& InputInfo::input_content_hash() const {
  return *input_content_hash_;
}
inline void InputInfo::set_input_content_hash(const ::std::string& value) {
  set_has_input_content_hash();
  if (input_content_hash_ == &::google::protobuf::internal::kEmptyString) {
    input_content_hash_ = new ::std::string;
  }
  input_content_hash_->assign(value);
}
inline void InputInfo::set_input_content_hash(const char* value) {
  set_has_input_content_hash();
  if (input_content_hash_ == &::google::protobuf::internal::kEmptyString) {
    input_content_hash_ = new ::std::string;
  }
  input_content_hash_->assign(value);
}
inline void InputInfo::set_input_content_hash(const char* value, size_t size) {
  set_has_input_content_hash();
  if (input_content_hash_ == &::google::protobuf::internal::kEmptyString) {
    input_content_hash_ = new ::std::string;
  }
  input_content_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InputInfo::mutable_input_content_hash() {
  set_has_input_content_hash();
  if (input_content_hash_ == &::google::protobuf::internal::kEmptyString) {
    input_content_hash_ = new ::std::string;
  }
  return input_content_hash_;
}
inline ::std::string* InputInfo::release_input_content_hash() {
  clear_has_input_content_hash();
  if (input_content_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = input_content_hash_;
    input_content_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string filename = 5;
inline bool InputInfo::has_filename() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InputInfo::set_has_filename() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InputInfo::clear_has_filename() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InputInfo::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& InputInfo::filename() const {
  return *filename_;
}
inline void InputInfo::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void InputInfo::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void InputInfo::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InputInfo::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* InputInfo::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool disable_further_processing = 8 [default = false];
inline bool InputInfo::has_disable_further_processing() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InputInfo::set_has_disable_further_processing() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InputInfo::clear_has_disable_further_processing() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InputInfo::clear_disable_further_processing() {
  disable_further_processing_ = false;
  clear_has_disable_further_processing();
}
inline bool InputInfo::disable_further_processing() const {
  return disable_further_processing_;
}
inline void InputInfo::set_disable_further_processing(bool value) {
  set_has_disable_further_processing();
  disable_further_processing_ = value;
}

// -------------------------------------------------------------------

// CachedResult

// optional bool optimizable = 1 [default = true];
inline bool CachedResult::has_optimizable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CachedResult::set_has_optimizable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CachedResult::clear_has_optimizable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CachedResult::clear_optimizable() {
  optimizable_ = true;
  clear_has_optimizable();
}
inline bool CachedResult::optimizable() const {
  return optimizable_;
}
inline void CachedResult::set_optimizable(bool value) {
  set_has_optimizable();
  optimizable_ = value;
}

// optional string url = 2;
inline bool CachedResult::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CachedResult::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CachedResult::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CachedResult::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& CachedResult::url() const {
  return *url_;
}
inline void CachedResult::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void CachedResult::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void CachedResult::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedResult::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* CachedResult::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool frozen = 5 [default = false];
inline bool CachedResult::has_frozen() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CachedResult::set_has_frozen() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CachedResult::clear_has_frozen() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CachedResult::clear_frozen() {
  frozen_ = false;
  clear_has_frozen();
}
inline bool CachedResult::frozen() const {
  return frozen_;
}
inline void CachedResult::set_frozen(bool value) {
  set_has_frozen();
  frozen_ = value;
}

// optional string hash = 6;
inline bool CachedResult::has_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CachedResult::set_has_hash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CachedResult::clear_has_hash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CachedResult::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& CachedResult::hash() const {
  return *hash_;
}
inline void CachedResult::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void CachedResult::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void CachedResult::set_hash(const char* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedResult::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* CachedResult::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string extension = 7;
inline bool CachedResult::has_extension() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CachedResult::set_has_extension() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CachedResult::clear_has_extension() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CachedResult::clear_extension() {
  if (extension_ != &::google::protobuf::internal::kEmptyString) {
    extension_->clear();
  }
  clear_has_extension();
}
inline const ::std::string& CachedResult::extension() const {
  return *extension_;
}
inline void CachedResult::set_extension(const ::std::string& value) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    extension_ = new ::std::string;
  }
  extension_->assign(value);
}
inline void CachedResult::set_extension(const char* value) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    extension_ = new ::std::string;
  }
  extension_->assign(value);
}
inline void CachedResult::set_extension(const char* value, size_t size) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    extension_ = new ::std::string;
  }
  extension_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedResult::mutable_extension() {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    extension_ = new ::std::string;
  }
  return extension_;
}
inline ::std::string* CachedResult::release_extension() {
  clear_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extension_;
    extension_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .net_instaweb.ImageDim image_file_dims = 11;
inline bool CachedResult::has_image_file_dims() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CachedResult::set_has_image_file_dims() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CachedResult::clear_has_image_file_dims() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CachedResult::clear_image_file_dims() {
  if (image_file_dims_ != NULL) image_file_dims_->::net_instaweb::ImageDim::Clear();
  clear_has_image_file_dims();
}
inline const ::net_instaweb::ImageDim& CachedResult::image_file_dims() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return image_file_dims_ != NULL ? *image_file_dims_ : *default_instance().image_file_dims_;
#else
  return image_file_dims_ != NULL ? *image_file_dims_ : *default_instance_->image_file_dims_;
#endif
}
inline ::net_instaweb::ImageDim* CachedResult::mutable_image_file_dims() {
  set_has_image_file_dims();
  if (image_file_dims_ == NULL) image_file_dims_ = new ::net_instaweb::ImageDim;
  return image_file_dims_;
}
inline ::net_instaweb::ImageDim* CachedResult::release_image_file_dims() {
  clear_has_image_file_dims();
  ::net_instaweb::ImageDim* temp = image_file_dims_;
  image_file_dims_ = NULL;
  return temp;
}

// optional bytes inlined_data = 12;
inline bool CachedResult::has_inlined_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CachedResult::set_has_inlined_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CachedResult::clear_has_inlined_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CachedResult::clear_inlined_data() {
  if (inlined_data_ != &::google::protobuf::internal::kEmptyString) {
    inlined_data_->clear();
  }
  clear_has_inlined_data();
}
inline const ::std::string& CachedResult::inlined_data() const {
  return *inlined_data_;
}
inline void CachedResult::set_inlined_data(const ::std::string& value) {
  set_has_inlined_data();
  if (inlined_data_ == &::google::protobuf::internal::kEmptyString) {
    inlined_data_ = new ::std::string;
  }
  inlined_data_->assign(value);
}
inline void CachedResult::set_inlined_data(const char* value) {
  set_has_inlined_data();
  if (inlined_data_ == &::google::protobuf::internal::kEmptyString) {
    inlined_data_ = new ::std::string;
  }
  inlined_data_->assign(value);
}
inline void CachedResult::set_inlined_data(const void* value, size_t size) {
  set_has_inlined_data();
  if (inlined_data_ == &::google::protobuf::internal::kEmptyString) {
    inlined_data_ = new ::std::string;
  }
  inlined_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedResult::mutable_inlined_data() {
  set_has_inlined_data();
  if (inlined_data_ == &::google::protobuf::internal::kEmptyString) {
    inlined_data_ = new ::std::string;
  }
  return inlined_data_;
}
inline ::std::string* CachedResult::release_inlined_data() {
  clear_has_inlined_data();
  if (inlined_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inlined_data_;
    inlined_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .net_instaweb.spriter.SpriterResult spriter_result = 13;
inline bool CachedResult::has_spriter_result() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CachedResult::set_has_spriter_result() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CachedResult::clear_has_spriter_result() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CachedResult::clear_spriter_result() {
  if (spriter_result_ != NULL) spriter_result_->::net_instaweb::spriter::SpriterResult::Clear();
  clear_has_spriter_result();
}
inline const ::net_instaweb::spriter::SpriterResult& CachedResult::spriter_result() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return spriter_result_ != NULL ? *spriter_result_ : *default_instance().spriter_result_;
#else
  return spriter_result_ != NULL ? *spriter_result_ : *default_instance_->spriter_result_;
#endif
}
inline ::net_instaweb::spriter::SpriterResult* CachedResult::mutable_spriter_result() {
  set_has_spriter_result();
  if (spriter_result_ == NULL) spriter_result_ = new ::net_instaweb::spriter::SpriterResult;
  return spriter_result_;
}
inline ::net_instaweb::spriter::SpriterResult* CachedResult::release_spriter_result() {
  clear_has_spriter_result();
  ::net_instaweb::spriter::SpriterResult* temp = spriter_result_;
  spriter_result_ = NULL;
  return temp;
}

// repeated .net_instaweb.InputInfo input = 14;
inline int CachedResult::input_size() const {
  return input_.size();
}
inline void CachedResult::clear_input() {
  input_.Clear();
}
inline const ::net_instaweb::InputInfo& CachedResult::input(int index) const {
  return input_.Get(index);
}
inline ::net_instaweb::InputInfo* CachedResult::mutable_input(int index) {
  return input_.Mutable(index);
}
inline ::net_instaweb::InputInfo* CachedResult::add_input() {
  return input_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::net_instaweb::InputInfo >&
CachedResult::input() const {
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::net_instaweb::InputInfo >*
CachedResult::mutable_input() {
  return &input_;
}

// optional int32 inlined_image_type = 15;
inline bool CachedResult::has_inlined_image_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CachedResult::set_has_inlined_image_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CachedResult::clear_has_inlined_image_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CachedResult::clear_inlined_image_type() {
  inlined_image_type_ = 0;
  clear_has_inlined_image_type();
}
inline ::google::protobuf::int32 CachedResult::inlined_image_type() const {
  return inlined_image_type_;
}
inline void CachedResult::set_inlined_image_type(::google::protobuf::int32 value) {
  set_has_inlined_image_type();
  inlined_image_type_ = value;
}

// optional bytes low_resolution_inlined_data = 16;
inline bool CachedResult::has_low_resolution_inlined_data() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CachedResult::set_has_low_resolution_inlined_data() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CachedResult::clear_has_low_resolution_inlined_data() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CachedResult::clear_low_resolution_inlined_data() {
  if (low_resolution_inlined_data_ != &::google::protobuf::internal::kEmptyString) {
    low_resolution_inlined_data_->clear();
  }
  clear_has_low_resolution_inlined_data();
}
inline const ::std::string& CachedResult::low_resolution_inlined_data() const {
  return *low_resolution_inlined_data_;
}
inline void CachedResult::set_low_resolution_inlined_data(const ::std::string& value) {
  set_has_low_resolution_inlined_data();
  if (low_resolution_inlined_data_ == &::google::protobuf::internal::kEmptyString) {
    low_resolution_inlined_data_ = new ::std::string;
  }
  low_resolution_inlined_data_->assign(value);
}
inline void CachedResult::set_low_resolution_inlined_data(const char* value) {
  set_has_low_resolution_inlined_data();
  if (low_resolution_inlined_data_ == &::google::protobuf::internal::kEmptyString) {
    low_resolution_inlined_data_ = new ::std::string;
  }
  low_resolution_inlined_data_->assign(value);
}
inline void CachedResult::set_low_resolution_inlined_data(const void* value, size_t size) {
  set_has_low_resolution_inlined_data();
  if (low_resolution_inlined_data_ == &::google::protobuf::internal::kEmptyString) {
    low_resolution_inlined_data_ = new ::std::string;
  }
  low_resolution_inlined_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedResult::mutable_low_resolution_inlined_data() {
  set_has_low_resolution_inlined_data();
  if (low_resolution_inlined_data_ == &::google::protobuf::internal::kEmptyString) {
    low_resolution_inlined_data_ = new ::std::string;
  }
  return low_resolution_inlined_data_;
}
inline ::std::string* CachedResult::release_low_resolution_inlined_data() {
  clear_has_low_resolution_inlined_data();
  if (low_resolution_inlined_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = low_resolution_inlined_data_;
    low_resolution_inlined_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 low_resolution_inlined_image_type = 17;
inline bool CachedResult::has_low_resolution_inlined_image_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CachedResult::set_has_low_resolution_inlined_image_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CachedResult::clear_has_low_resolution_inlined_image_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CachedResult::clear_low_resolution_inlined_image_type() {
  low_resolution_inlined_image_type_ = 0;
  clear_has_low_resolution_inlined_image_type();
}
inline ::google::protobuf::int32 CachedResult::low_resolution_inlined_image_type() const {
  return low_resolution_inlined_image_type_;
}
inline void CachedResult::set_low_resolution_inlined_image_type(::google::protobuf::int32 value) {
  set_has_low_resolution_inlined_image_type();
  low_resolution_inlined_image_type_ = value;
}

// optional bool url_relocatable = 18 [default = true];
inline bool CachedResult::has_url_relocatable() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CachedResult::set_has_url_relocatable() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CachedResult::clear_has_url_relocatable() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CachedResult::clear_url_relocatable() {
  url_relocatable_ = true;
  clear_has_url_relocatable();
}
inline bool CachedResult::url_relocatable() const {
  return url_relocatable_;
}
inline void CachedResult::set_url_relocatable(bool value) {
  set_has_url_relocatable();
  url_relocatable_ = value;
}

// optional bool canonicalize_url = 19 [default = false];
inline bool CachedResult::has_canonicalize_url() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CachedResult::set_has_canonicalize_url() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CachedResult::clear_has_canonicalize_url() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CachedResult::clear_canonicalize_url() {
  canonicalize_url_ = false;
  clear_has_canonicalize_url();
}
inline bool CachedResult::canonicalize_url() const {
  return canonicalize_url_;
}
inline void CachedResult::set_canonicalize_url(bool value) {
  set_has_canonicalize_url();
  canonicalize_url_ = value;
}

// optional int64 size = 20;
inline bool CachedResult::has_size() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CachedResult::set_has_size() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CachedResult::clear_has_size() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CachedResult::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 CachedResult::size() const {
  return size_;
}
inline void CachedResult::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// OutputPartitions

// repeated .net_instaweb.CachedResult partition = 1;
inline int OutputPartitions::partition_size() const {
  return partition_.size();
}
inline void OutputPartitions::clear_partition() {
  partition_.Clear();
}
inline const ::net_instaweb::CachedResult& OutputPartitions::partition(int index) const {
  return partition_.Get(index);
}
inline ::net_instaweb::CachedResult* OutputPartitions::mutable_partition(int index) {
  return partition_.Mutable(index);
}
inline ::net_instaweb::CachedResult* OutputPartitions::add_partition() {
  return partition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::net_instaweb::CachedResult >&
OutputPartitions::partition() const {
  return partition_;
}
inline ::google::protobuf::RepeatedPtrField< ::net_instaweb::CachedResult >*
OutputPartitions::mutable_partition() {
  return &partition_;
}

// repeated .net_instaweb.InputInfo other_dependency = 2;
inline int OutputPartitions::other_dependency_size() const {
  return other_dependency_.size();
}
inline void OutputPartitions::clear_other_dependency() {
  other_dependency_.Clear();
}
inline const ::net_instaweb::InputInfo& OutputPartitions::other_dependency(int index) const {
  return other_dependency_.Get(index);
}
inline ::net_instaweb::InputInfo* OutputPartitions::mutable_other_dependency(int index) {
  return other_dependency_.Mutable(index);
}
inline ::net_instaweb::InputInfo* OutputPartitions::add_other_dependency() {
  return other_dependency_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::net_instaweb::InputInfo >&
OutputPartitions::other_dependency() const {
  return other_dependency_;
}
inline ::google::protobuf::RepeatedPtrField< ::net_instaweb::InputInfo >*
OutputPartitions::mutable_other_dependency() {
  return &other_dependency_;
}

// -------------------------------------------------------------------

// ResourceContext

// optional .net_instaweb.ImageDim desired_image_dims = 1;
inline bool ResourceContext::has_desired_image_dims() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceContext::set_has_desired_image_dims() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceContext::clear_has_desired_image_dims() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceContext::clear_desired_image_dims() {
  if (desired_image_dims_ != NULL) desired_image_dims_->::net_instaweb::ImageDim::Clear();
  clear_has_desired_image_dims();
}
inline const ::net_instaweb::ImageDim& ResourceContext::desired_image_dims() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return desired_image_dims_ != NULL ? *desired_image_dims_ : *default_instance().desired_image_dims_;
#else
  return desired_image_dims_ != NULL ? *desired_image_dims_ : *default_instance_->desired_image_dims_;
#endif
}
inline ::net_instaweb::ImageDim* ResourceContext::mutable_desired_image_dims() {
  set_has_desired_image_dims();
  if (desired_image_dims_ == NULL) desired_image_dims_ = new ::net_instaweb::ImageDim;
  return desired_image_dims_;
}
inline ::net_instaweb::ImageDim* ResourceContext::release_desired_image_dims() {
  clear_has_desired_image_dims();
  ::net_instaweb::ImageDim* temp = desired_image_dims_;
  desired_image_dims_ = NULL;
  return temp;
}

// optional bool attempt_webp = 2 [default = false, deprecated = true];
inline bool ResourceContext::has_attempt_webp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceContext::set_has_attempt_webp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceContext::clear_has_attempt_webp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceContext::clear_attempt_webp() {
  attempt_webp_ = false;
  clear_has_attempt_webp();
}
inline bool ResourceContext::attempt_webp() const {
  return attempt_webp_;
}
inline void ResourceContext::set_attempt_webp(bool value) {
  set_has_attempt_webp();
  attempt_webp_ = value;
}

// optional bool inline_images = 3 [default = true];
inline bool ResourceContext::has_inline_images() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceContext::set_has_inline_images() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceContext::clear_has_inline_images() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceContext::clear_inline_images() {
  inline_images_ = true;
  clear_has_inline_images();
}
inline bool ResourceContext::inline_images() const {
  return inline_images_;
}
inline void ResourceContext::set_inline_images(bool value) {
  set_has_inline_images();
  inline_images_ = value;
}

// optional bool mobile_user_agent = 4 [default = false];
inline bool ResourceContext::has_mobile_user_agent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceContext::set_has_mobile_user_agent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceContext::clear_has_mobile_user_agent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceContext::clear_mobile_user_agent() {
  mobile_user_agent_ = false;
  clear_has_mobile_user_agent();
}
inline bool ResourceContext::mobile_user_agent() const {
  return mobile_user_agent_;
}
inline void ResourceContext::set_mobile_user_agent(bool value) {
  set_has_mobile_user_agent();
  mobile_user_agent_ = value;
}

// optional .net_instaweb.ResourceContext.LibWebpLevel libwebp_level = 5 [default = LIBWEBP_NONE];
inline bool ResourceContext::has_libwebp_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResourceContext::set_has_libwebp_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResourceContext::clear_has_libwebp_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResourceContext::clear_libwebp_level() {
  libwebp_level_ = 0;
  clear_has_libwebp_level();
}
inline ::net_instaweb::ResourceContext_LibWebpLevel ResourceContext::libwebp_level() const {
  return static_cast< ::net_instaweb::ResourceContext_LibWebpLevel >(libwebp_level_);
}
inline void ResourceContext::set_libwebp_level(::net_instaweb::ResourceContext_LibWebpLevel value) {
  GOOGLE_DCHECK(::net_instaweb::ResourceContext_LibWebpLevel_IsValid(value));
  set_has_libwebp_level();
  libwebp_level_ = value;
}

// optional .net_instaweb.ImageDim user_agent_screen_resolution = 6;
inline bool ResourceContext::has_user_agent_screen_resolution() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResourceContext::set_has_user_agent_screen_resolution() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResourceContext::clear_has_user_agent_screen_resolution() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResourceContext::clear_user_agent_screen_resolution() {
  if (user_agent_screen_resolution_ != NULL) user_agent_screen_resolution_->::net_instaweb::ImageDim::Clear();
  clear_has_user_agent_screen_resolution();
}
inline const ::net_instaweb::ImageDim& ResourceContext::user_agent_screen_resolution() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_agent_screen_resolution_ != NULL ? *user_agent_screen_resolution_ : *default_instance().user_agent_screen_resolution_;
#else
  return user_agent_screen_resolution_ != NULL ? *user_agent_screen_resolution_ : *default_instance_->user_agent_screen_resolution_;
#endif
}
inline ::net_instaweb::ImageDim* ResourceContext::mutable_user_agent_screen_resolution() {
  set_has_user_agent_screen_resolution();
  if (user_agent_screen_resolution_ == NULL) user_agent_screen_resolution_ = new ::net_instaweb::ImageDim;
  return user_agent_screen_resolution_;
}
inline ::net_instaweb::ImageDim* ResourceContext::release_user_agent_screen_resolution() {
  clear_has_user_agent_screen_resolution();
  ::net_instaweb::ImageDim* temp = user_agent_screen_resolution_;
  user_agent_screen_resolution_ = NULL;
  return temp;
}

// optional bool use_small_screen_quality = 7 [default = false];
inline bool ResourceContext::has_use_small_screen_quality() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResourceContext::set_has_use_small_screen_quality() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResourceContext::clear_has_use_small_screen_quality() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResourceContext::clear_use_small_screen_quality() {
  use_small_screen_quality_ = false;
  clear_has_use_small_screen_quality();
}
inline bool ResourceContext::use_small_screen_quality() const {
  return use_small_screen_quality_;
}
inline void ResourceContext::set_use_small_screen_quality(bool value) {
  set_has_use_small_screen_quality();
  use_small_screen_quality_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace net_instaweb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_net_2finstaweb_2frewriter_2fcached_5fresult_2eproto__INCLUDED
