// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pagespeed_proto_formatter.proto

#ifndef PROTOBUF_pagespeed_5fproto_5fformatter_2eproto__INCLUDED
#define PROTOBUF_pagespeed_5fproto_5fformatter_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace pagespeed {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pagespeed_5fproto_5fformatter_2eproto();
void protobuf_AssignDesc_pagespeed_5fproto_5fformatter_2eproto();
void protobuf_ShutdownFile_pagespeed_5fproto_5fformatter_2eproto();

class FormatArgument;
class FormatString;
class FormattedUrlResult;
class FormattedUrlBlockResults;
class FormattedRuleResults;
class FormattedResults;

enum FormatArgument_ArgumentType {
  FormatArgument_ArgumentType_URL = 1,
  FormatArgument_ArgumentType_STRING_LITERAL = 2,
  FormatArgument_ArgumentType_INT_LITERAL = 3,
  FormatArgument_ArgumentType_BYTES = 4,
  FormatArgument_ArgumentType_DURATION = 5,
  FormatArgument_ArgumentType_VERBATIM_STRING = 6,
  FormatArgument_ArgumentType_PERCENTAGE = 7
};
bool FormatArgument_ArgumentType_IsValid(int value);
const FormatArgument_ArgumentType FormatArgument_ArgumentType_ArgumentType_MIN = FormatArgument_ArgumentType_URL;
const FormatArgument_ArgumentType FormatArgument_ArgumentType_ArgumentType_MAX = FormatArgument_ArgumentType_PERCENTAGE;
const int FormatArgument_ArgumentType_ArgumentType_ARRAYSIZE = FormatArgument_ArgumentType_ArgumentType_MAX + 1;

// ===================================================================

class FormatArgument : public ::google::protobuf::MessageLite {
 public:
  FormatArgument();
  virtual ~FormatArgument();
  
  FormatArgument(const FormatArgument& from);
  
  inline FormatArgument& operator=(const FormatArgument& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FormatArgument& default_instance();
  
  void Swap(FormatArgument* other);
  
  // implements Message ----------------------------------------------
  
  FormatArgument* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FormatArgument& from);
  void MergeFrom(const FormatArgument& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef FormatArgument_ArgumentType ArgumentType;
  static const ArgumentType URL = FormatArgument_ArgumentType_URL;
  static const ArgumentType STRING_LITERAL = FormatArgument_ArgumentType_STRING_LITERAL;
  static const ArgumentType INT_LITERAL = FormatArgument_ArgumentType_INT_LITERAL;
  static const ArgumentType BYTES = FormatArgument_ArgumentType_BYTES;
  static const ArgumentType DURATION = FormatArgument_ArgumentType_DURATION;
  static const ArgumentType VERBATIM_STRING = FormatArgument_ArgumentType_VERBATIM_STRING;
  static const ArgumentType PERCENTAGE = FormatArgument_ArgumentType_PERCENTAGE;
  static inline bool ArgumentType_IsValid(int value) {
    return FormatArgument_ArgumentType_IsValid(value);
  }
  static const ArgumentType ArgumentType_MIN =
    FormatArgument_ArgumentType_ArgumentType_MIN;
  static const ArgumentType ArgumentType_MAX =
    FormatArgument_ArgumentType_ArgumentType_MAX;
  static const int ArgumentType_ARRAYSIZE =
    FormatArgument_ArgumentType_ArgumentType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .pagespeed.FormatArgument.ArgumentType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pagespeed::FormatArgument_ArgumentType type() const;
  inline void set_type(::pagespeed::FormatArgument_ArgumentType value);
  
  // optional string string_value = 2;
  inline bool has_string_value() const;
  inline void clear_string_value();
  static const int kStringValueFieldNumber = 2;
  inline const ::std::string& string_value() const;
  inline void set_string_value(const ::std::string& value);
  inline void set_string_value(const char* value);
  inline void set_string_value(const char* value, size_t size);
  inline ::std::string* mutable_string_value();
  inline ::std::string* release_string_value();
  
  // optional int64 int_value = 3;
  inline bool has_int_value() const;
  inline void clear_int_value();
  static const int kIntValueFieldNumber = 3;
  inline ::google::protobuf::int64 int_value() const;
  inline void set_int_value(::google::protobuf::int64 value);
  
  // required string localized_value = 4;
  inline bool has_localized_value() const;
  inline void clear_localized_value();
  static const int kLocalizedValueFieldNumber = 4;
  inline const ::std::string& localized_value() const;
  inline void set_localized_value(const ::std::string& value);
  inline void set_localized_value(const char* value);
  inline void set_localized_value(const char* value, size_t size);
  inline ::std::string* mutable_localized_value();
  inline ::std::string* release_localized_value();
  
  // @@protoc_insertion_point(class_scope:pagespeed.FormatArgument)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_string_value();
  inline void clear_has_string_value();
  inline void set_has_int_value();
  inline void clear_has_int_value();
  inline void set_has_localized_value();
  inline void clear_has_localized_value();
  
  ::std::string* string_value_;
  ::google::protobuf::int64 int_value_;
  ::std::string* localized_value_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pagespeed_5fproto_5fformatter_2eproto();
  friend void protobuf_AssignDesc_pagespeed_5fproto_5fformatter_2eproto();
  friend void protobuf_ShutdownFile_pagespeed_5fproto_5fformatter_2eproto();
  
  void InitAsDefaultInstance();
  static FormatArgument* default_instance_;
};
// -------------------------------------------------------------------

class FormatString : public ::google::protobuf::MessageLite {
 public:
  FormatString();
  virtual ~FormatString();
  
  FormatString(const FormatString& from);
  
  inline FormatString& operator=(const FormatString& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FormatString& default_instance();
  
  void Swap(FormatString* other);
  
  // implements Message ----------------------------------------------
  
  FormatString* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FormatString& from);
  void MergeFrom(const FormatString& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string format = 1;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 1;
  inline const ::std::string& format() const;
  inline void set_format(const ::std::string& value);
  inline void set_format(const char* value);
  inline void set_format(const char* value, size_t size);
  inline ::std::string* mutable_format();
  inline ::std::string* release_format();
  
  // repeated .pagespeed.FormatArgument args = 2;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::pagespeed::FormatArgument& args(int index) const;
  inline ::pagespeed::FormatArgument* mutable_args(int index);
  inline ::pagespeed::FormatArgument* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::pagespeed::FormatArgument >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::pagespeed::FormatArgument >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:pagespeed.FormatString)
 private:
  inline void set_has_format();
  inline void clear_has_format();
  
  ::std::string* format_;
  ::google::protobuf::RepeatedPtrField< ::pagespeed::FormatArgument > args_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pagespeed_5fproto_5fformatter_2eproto();
  friend void protobuf_AssignDesc_pagespeed_5fproto_5fformatter_2eproto();
  friend void protobuf_ShutdownFile_pagespeed_5fproto_5fformatter_2eproto();
  
  void InitAsDefaultInstance();
  static FormatString* default_instance_;
};
// -------------------------------------------------------------------

class FormattedUrlResult : public ::google::protobuf::MessageLite {
 public:
  FormattedUrlResult();
  virtual ~FormattedUrlResult();
  
  FormattedUrlResult(const FormattedUrlResult& from);
  
  inline FormattedUrlResult& operator=(const FormattedUrlResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FormattedUrlResult& default_instance();
  
  void Swap(FormattedUrlResult* other);
  
  // implements Message ----------------------------------------------
  
  FormattedUrlResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FormattedUrlResult& from);
  void MergeFrom(const FormattedUrlResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .pagespeed.FormatString result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::pagespeed::FormatString& result() const;
  inline ::pagespeed::FormatString* mutable_result();
  inline ::pagespeed::FormatString* release_result();
  
  // repeated .pagespeed.FormatString details = 2;
  inline int details_size() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 2;
  inline const ::pagespeed::FormatString& details(int index) const;
  inline ::pagespeed::FormatString* mutable_details(int index);
  inline ::pagespeed::FormatString* add_details();
  inline const ::google::protobuf::RepeatedPtrField< ::pagespeed::FormatString >&
      details() const;
  inline ::google::protobuf::RepeatedPtrField< ::pagespeed::FormatString >*
      mutable_details();
  
  // optional int32 associated_result_id = 3;
  inline bool has_associated_result_id() const;
  inline void clear_associated_result_id();
  static const int kAssociatedResultIdFieldNumber = 3;
  inline ::google::protobuf::int32 associated_result_id() const;
  inline void set_associated_result_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pagespeed.FormattedUrlResult)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_associated_result_id();
  inline void clear_has_associated_result_id();
  
  ::pagespeed::FormatString* result_;
  ::google::protobuf::RepeatedPtrField< ::pagespeed::FormatString > details_;
  ::google::protobuf::int32 associated_result_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pagespeed_5fproto_5fformatter_2eproto();
  friend void protobuf_AssignDesc_pagespeed_5fproto_5fformatter_2eproto();
  friend void protobuf_ShutdownFile_pagespeed_5fproto_5fformatter_2eproto();
  
  void InitAsDefaultInstance();
  static FormattedUrlResult* default_instance_;
};
// -------------------------------------------------------------------

class FormattedUrlBlockResults : public ::google::protobuf::MessageLite {
 public:
  FormattedUrlBlockResults();
  virtual ~FormattedUrlBlockResults();
  
  FormattedUrlBlockResults(const FormattedUrlBlockResults& from);
  
  inline FormattedUrlBlockResults& operator=(const FormattedUrlBlockResults& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FormattedUrlBlockResults& default_instance();
  
  void Swap(FormattedUrlBlockResults* other);
  
  // implements Message ----------------------------------------------
  
  FormattedUrlBlockResults* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FormattedUrlBlockResults& from);
  void MergeFrom(const FormattedUrlBlockResults& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .pagespeed.FormatString header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::pagespeed::FormatString& header() const;
  inline ::pagespeed::FormatString* mutable_header();
  inline ::pagespeed::FormatString* release_header();
  
  // repeated .pagespeed.FormattedUrlResult urls = 2;
  inline int urls_size() const;
  inline void clear_urls();
  static const int kUrlsFieldNumber = 2;
  inline const ::pagespeed::FormattedUrlResult& urls(int index) const;
  inline ::pagespeed::FormattedUrlResult* mutable_urls(int index);
  inline ::pagespeed::FormattedUrlResult* add_urls();
  inline const ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedUrlResult >&
      urls() const;
  inline ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedUrlResult >*
      mutable_urls();
  
  // optional int32 associated_result_id = 3;
  inline bool has_associated_result_id() const;
  inline void clear_associated_result_id();
  static const int kAssociatedResultIdFieldNumber = 3;
  inline ::google::protobuf::int32 associated_result_id() const;
  inline void set_associated_result_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pagespeed.FormattedUrlBlockResults)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_associated_result_id();
  inline void clear_has_associated_result_id();
  
  ::pagespeed::FormatString* header_;
  ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedUrlResult > urls_;
  ::google::protobuf::int32 associated_result_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pagespeed_5fproto_5fformatter_2eproto();
  friend void protobuf_AssignDesc_pagespeed_5fproto_5fformatter_2eproto();
  friend void protobuf_ShutdownFile_pagespeed_5fproto_5fformatter_2eproto();
  
  void InitAsDefaultInstance();
  static FormattedUrlBlockResults* default_instance_;
};
// -------------------------------------------------------------------

class FormattedRuleResults : public ::google::protobuf::MessageLite {
 public:
  FormattedRuleResults();
  virtual ~FormattedRuleResults();
  
  FormattedRuleResults(const FormattedRuleResults& from);
  
  inline FormattedRuleResults& operator=(const FormattedRuleResults& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FormattedRuleResults& default_instance();
  
  void Swap(FormattedRuleResults* other);
  
  // implements Message ----------------------------------------------
  
  FormattedRuleResults* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FormattedRuleResults& from);
  void MergeFrom(const FormattedRuleResults& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string rule_name = 1;
  inline bool has_rule_name() const;
  inline void clear_rule_name();
  static const int kRuleNameFieldNumber = 1;
  inline const ::std::string& rule_name() const;
  inline void set_rule_name(const ::std::string& value);
  inline void set_rule_name(const char* value);
  inline void set_rule_name(const char* value, size_t size);
  inline ::std::string* mutable_rule_name();
  inline ::std::string* release_rule_name();
  
  // required string localized_rule_name = 2;
  inline bool has_localized_rule_name() const;
  inline void clear_localized_rule_name();
  static const int kLocalizedRuleNameFieldNumber = 2;
  inline const ::std::string& localized_rule_name() const;
  inline void set_localized_rule_name(const ::std::string& value);
  inline void set_localized_rule_name(const char* value);
  inline void set_localized_rule_name(const char* value, size_t size);
  inline ::std::string* mutable_localized_rule_name();
  inline ::std::string* release_localized_rule_name();
  
  // repeated .pagespeed.FormattedUrlBlockResults url_blocks = 3;
  inline int url_blocks_size() const;
  inline void clear_url_blocks();
  static const int kUrlBlocksFieldNumber = 3;
  inline const ::pagespeed::FormattedUrlBlockResults& url_blocks(int index) const;
  inline ::pagespeed::FormattedUrlBlockResults* mutable_url_blocks(int index);
  inline ::pagespeed::FormattedUrlBlockResults* add_url_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedUrlBlockResults >&
      url_blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedUrlBlockResults >*
      mutable_url_blocks();
  
  // optional int32 rule_score = 4;
  inline bool has_rule_score() const;
  inline void clear_rule_score();
  static const int kRuleScoreFieldNumber = 4;
  inline ::google::protobuf::int32 rule_score() const;
  inline void set_rule_score(::google::protobuf::int32 value);
  
  // optional double rule_impact = 5;
  inline bool has_rule_impact() const;
  inline void clear_rule_impact();
  static const int kRuleImpactFieldNumber = 5;
  inline double rule_impact() const;
  inline void set_rule_impact(double value);
  
  // optional bool experimental = 6;
  inline bool has_experimental() const;
  inline void clear_experimental();
  static const int kExperimentalFieldNumber = 6;
  inline bool experimental() const;
  inline void set_experimental(bool value);
  
  // @@protoc_insertion_point(class_scope:pagespeed.FormattedRuleResults)
 private:
  inline void set_has_rule_name();
  inline void clear_has_rule_name();
  inline void set_has_localized_rule_name();
  inline void clear_has_localized_rule_name();
  inline void set_has_rule_score();
  inline void clear_has_rule_score();
  inline void set_has_rule_impact();
  inline void clear_has_rule_impact();
  inline void set_has_experimental();
  inline void clear_has_experimental();
  
  ::std::string* rule_name_;
  ::std::string* localized_rule_name_;
  ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedUrlBlockResults > url_blocks_;
  double rule_impact_;
  ::google::protobuf::int32 rule_score_;
  bool experimental_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_pagespeed_5fproto_5fformatter_2eproto();
  friend void protobuf_AssignDesc_pagespeed_5fproto_5fformatter_2eproto();
  friend void protobuf_ShutdownFile_pagespeed_5fproto_5fformatter_2eproto();
  
  void InitAsDefaultInstance();
  static FormattedRuleResults* default_instance_;
};
// -------------------------------------------------------------------

class FormattedResults : public ::google::protobuf::MessageLite {
 public:
  FormattedResults();
  virtual ~FormattedResults();
  
  FormattedResults(const FormattedResults& from);
  
  inline FormattedResults& operator=(const FormattedResults& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FormattedResults& default_instance();
  
  void Swap(FormattedResults* other);
  
  // implements Message ----------------------------------------------
  
  FormattedResults* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FormattedResults& from);
  void MergeFrom(const FormattedResults& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string locale = 1;
  inline bool has_locale() const;
  inline void clear_locale();
  static const int kLocaleFieldNumber = 1;
  inline const ::std::string& locale() const;
  inline void set_locale(const ::std::string& value);
  inline void set_locale(const char* value);
  inline void set_locale(const char* value, size_t size);
  inline ::std::string* mutable_locale();
  inline ::std::string* release_locale();
  
  // repeated .pagespeed.FormattedRuleResults rule_results = 2;
  inline int rule_results_size() const;
  inline void clear_rule_results();
  static const int kRuleResultsFieldNumber = 2;
  inline const ::pagespeed::FormattedRuleResults& rule_results(int index) const;
  inline ::pagespeed::FormattedRuleResults* mutable_rule_results(int index);
  inline ::pagespeed::FormattedRuleResults* add_rule_results();
  inline const ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedRuleResults >&
      rule_results() const;
  inline ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedRuleResults >*
      mutable_rule_results();
  
  // optional int32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pagespeed.FormattedResults)
 private:
  inline void set_has_locale();
  inline void clear_has_locale();
  inline void set_has_score();
  inline void clear_has_score();
  
  ::std::string* locale_;
  ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedRuleResults > rule_results_;
  ::google::protobuf::int32 score_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pagespeed_5fproto_5fformatter_2eproto();
  friend void protobuf_AssignDesc_pagespeed_5fproto_5fformatter_2eproto();
  friend void protobuf_ShutdownFile_pagespeed_5fproto_5fformatter_2eproto();
  
  void InitAsDefaultInstance();
  static FormattedResults* default_instance_;
};
// ===================================================================


// ===================================================================

// FormatArgument

// required .pagespeed.FormatArgument.ArgumentType type = 1;
inline bool FormatArgument::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormatArgument::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormatArgument::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormatArgument::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pagespeed::FormatArgument_ArgumentType FormatArgument::type() const {
  return static_cast< ::pagespeed::FormatArgument_ArgumentType >(type_);
}
inline void FormatArgument::set_type(::pagespeed::FormatArgument_ArgumentType value) {
  GOOGLE_DCHECK(::pagespeed::FormatArgument_ArgumentType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string string_value = 2;
inline bool FormatArgument::has_string_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormatArgument::set_has_string_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormatArgument::clear_has_string_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormatArgument::clear_string_value() {
  if (string_value_ != &::google::protobuf::internal::kEmptyString) {
    string_value_->clear();
  }
  clear_has_string_value();
}
inline const ::std::string& FormatArgument::string_value() const {
  return *string_value_;
}
inline void FormatArgument::set_string_value(const ::std::string& value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void FormatArgument::set_string_value(const char* value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void FormatArgument::set_string_value(const char* value, size_t size) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormatArgument::mutable_string_value() {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  return string_value_;
}
inline ::std::string* FormatArgument::release_string_value() {
  clear_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_value_;
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 int_value = 3;
inline bool FormatArgument::has_int_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormatArgument::set_has_int_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormatArgument::clear_has_int_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FormatArgument::clear_int_value() {
  int_value_ = GOOGLE_LONGLONG(0);
  clear_has_int_value();
}
inline ::google::protobuf::int64 FormatArgument::int_value() const {
  return int_value_;
}
inline void FormatArgument::set_int_value(::google::protobuf::int64 value) {
  set_has_int_value();
  int_value_ = value;
}

// required string localized_value = 4;
inline bool FormatArgument::has_localized_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FormatArgument::set_has_localized_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FormatArgument::clear_has_localized_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FormatArgument::clear_localized_value() {
  if (localized_value_ != &::google::protobuf::internal::kEmptyString) {
    localized_value_->clear();
  }
  clear_has_localized_value();
}
inline const ::std::string& FormatArgument::localized_value() const {
  return *localized_value_;
}
inline void FormatArgument::set_localized_value(const ::std::string& value) {
  set_has_localized_value();
  if (localized_value_ == &::google::protobuf::internal::kEmptyString) {
    localized_value_ = new ::std::string;
  }
  localized_value_->assign(value);
}
inline void FormatArgument::set_localized_value(const char* value) {
  set_has_localized_value();
  if (localized_value_ == &::google::protobuf::internal::kEmptyString) {
    localized_value_ = new ::std::string;
  }
  localized_value_->assign(value);
}
inline void FormatArgument::set_localized_value(const char* value, size_t size) {
  set_has_localized_value();
  if (localized_value_ == &::google::protobuf::internal::kEmptyString) {
    localized_value_ = new ::std::string;
  }
  localized_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormatArgument::mutable_localized_value() {
  set_has_localized_value();
  if (localized_value_ == &::google::protobuf::internal::kEmptyString) {
    localized_value_ = new ::std::string;
  }
  return localized_value_;
}
inline ::std::string* FormatArgument::release_localized_value() {
  clear_has_localized_value();
  if (localized_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localized_value_;
    localized_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FormatString

// required string format = 1;
inline bool FormatString::has_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormatString::set_has_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormatString::clear_has_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormatString::clear_format() {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    format_->clear();
  }
  clear_has_format();
}
inline const ::std::string& FormatString::format() const {
  return *format_;
}
inline void FormatString::set_format(const ::std::string& value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void FormatString::set_format(const char* value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void FormatString::set_format(const char* value, size_t size) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormatString::mutable_format() {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  return format_;
}
inline ::std::string* FormatString::release_format() {
  clear_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = format_;
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .pagespeed.FormatArgument args = 2;
inline int FormatString::args_size() const {
  return args_.size();
}
inline void FormatString::clear_args() {
  args_.Clear();
}
inline const ::pagespeed::FormatArgument& FormatString::args(int index) const {
  return args_.Get(index);
}
inline ::pagespeed::FormatArgument* FormatString::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::pagespeed::FormatArgument* FormatString::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pagespeed::FormatArgument >&
FormatString::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::pagespeed::FormatArgument >*
FormatString::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// FormattedUrlResult

// required .pagespeed.FormatString result = 1;
inline bool FormattedUrlResult::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormattedUrlResult::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormattedUrlResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormattedUrlResult::clear_result() {
  if (result_ != NULL) result_->::pagespeed::FormatString::Clear();
  clear_has_result();
}
inline const ::pagespeed::FormatString& FormattedUrlResult::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::pagespeed::FormatString* FormattedUrlResult::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::pagespeed::FormatString;
  return result_;
}
inline ::pagespeed::FormatString* FormattedUrlResult::release_result() {
  clear_has_result();
  ::pagespeed::FormatString* temp = result_;
  result_ = NULL;
  return temp;
}

// repeated .pagespeed.FormatString details = 2;
inline int FormattedUrlResult::details_size() const {
  return details_.size();
}
inline void FormattedUrlResult::clear_details() {
  details_.Clear();
}
inline const ::pagespeed::FormatString& FormattedUrlResult::details(int index) const {
  return details_.Get(index);
}
inline ::pagespeed::FormatString* FormattedUrlResult::mutable_details(int index) {
  return details_.Mutable(index);
}
inline ::pagespeed::FormatString* FormattedUrlResult::add_details() {
  return details_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pagespeed::FormatString >&
FormattedUrlResult::details() const {
  return details_;
}
inline ::google::protobuf::RepeatedPtrField< ::pagespeed::FormatString >*
FormattedUrlResult::mutable_details() {
  return &details_;
}

// optional int32 associated_result_id = 3;
inline bool FormattedUrlResult::has_associated_result_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormattedUrlResult::set_has_associated_result_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormattedUrlResult::clear_has_associated_result_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FormattedUrlResult::clear_associated_result_id() {
  associated_result_id_ = 0;
  clear_has_associated_result_id();
}
inline ::google::protobuf::int32 FormattedUrlResult::associated_result_id() const {
  return associated_result_id_;
}
inline void FormattedUrlResult::set_associated_result_id(::google::protobuf::int32 value) {
  set_has_associated_result_id();
  associated_result_id_ = value;
}

// -------------------------------------------------------------------

// FormattedUrlBlockResults

// optional .pagespeed.FormatString header = 1;
inline bool FormattedUrlBlockResults::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormattedUrlBlockResults::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormattedUrlBlockResults::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormattedUrlBlockResults::clear_header() {
  if (header_ != NULL) header_->::pagespeed::FormatString::Clear();
  clear_has_header();
}
inline const ::pagespeed::FormatString& FormattedUrlBlockResults::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::pagespeed::FormatString* FormattedUrlBlockResults::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::pagespeed::FormatString;
  return header_;
}
inline ::pagespeed::FormatString* FormattedUrlBlockResults::release_header() {
  clear_has_header();
  ::pagespeed::FormatString* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .pagespeed.FormattedUrlResult urls = 2;
inline int FormattedUrlBlockResults::urls_size() const {
  return urls_.size();
}
inline void FormattedUrlBlockResults::clear_urls() {
  urls_.Clear();
}
inline const ::pagespeed::FormattedUrlResult& FormattedUrlBlockResults::urls(int index) const {
  return urls_.Get(index);
}
inline ::pagespeed::FormattedUrlResult* FormattedUrlBlockResults::mutable_urls(int index) {
  return urls_.Mutable(index);
}
inline ::pagespeed::FormattedUrlResult* FormattedUrlBlockResults::add_urls() {
  return urls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedUrlResult >&
FormattedUrlBlockResults::urls() const {
  return urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedUrlResult >*
FormattedUrlBlockResults::mutable_urls() {
  return &urls_;
}

// optional int32 associated_result_id = 3;
inline bool FormattedUrlBlockResults::has_associated_result_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormattedUrlBlockResults::set_has_associated_result_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormattedUrlBlockResults::clear_has_associated_result_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FormattedUrlBlockResults::clear_associated_result_id() {
  associated_result_id_ = 0;
  clear_has_associated_result_id();
}
inline ::google::protobuf::int32 FormattedUrlBlockResults::associated_result_id() const {
  return associated_result_id_;
}
inline void FormattedUrlBlockResults::set_associated_result_id(::google::protobuf::int32 value) {
  set_has_associated_result_id();
  associated_result_id_ = value;
}

// -------------------------------------------------------------------

// FormattedRuleResults

// required string rule_name = 1;
inline bool FormattedRuleResults::has_rule_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormattedRuleResults::set_has_rule_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormattedRuleResults::clear_has_rule_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormattedRuleResults::clear_rule_name() {
  if (rule_name_ != &::google::protobuf::internal::kEmptyString) {
    rule_name_->clear();
  }
  clear_has_rule_name();
}
inline const ::std::string& FormattedRuleResults::rule_name() const {
  return *rule_name_;
}
inline void FormattedRuleResults::set_rule_name(const ::std::string& value) {
  set_has_rule_name();
  if (rule_name_ == &::google::protobuf::internal::kEmptyString) {
    rule_name_ = new ::std::string;
  }
  rule_name_->assign(value);
}
inline void FormattedRuleResults::set_rule_name(const char* value) {
  set_has_rule_name();
  if (rule_name_ == &::google::protobuf::internal::kEmptyString) {
    rule_name_ = new ::std::string;
  }
  rule_name_->assign(value);
}
inline void FormattedRuleResults::set_rule_name(const char* value, size_t size) {
  set_has_rule_name();
  if (rule_name_ == &::google::protobuf::internal::kEmptyString) {
    rule_name_ = new ::std::string;
  }
  rule_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormattedRuleResults::mutable_rule_name() {
  set_has_rule_name();
  if (rule_name_ == &::google::protobuf::internal::kEmptyString) {
    rule_name_ = new ::std::string;
  }
  return rule_name_;
}
inline ::std::string* FormattedRuleResults::release_rule_name() {
  clear_has_rule_name();
  if (rule_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rule_name_;
    rule_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string localized_rule_name = 2;
inline bool FormattedRuleResults::has_localized_rule_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormattedRuleResults::set_has_localized_rule_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormattedRuleResults::clear_has_localized_rule_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormattedRuleResults::clear_localized_rule_name() {
  if (localized_rule_name_ != &::google::protobuf::internal::kEmptyString) {
    localized_rule_name_->clear();
  }
  clear_has_localized_rule_name();
}
inline const ::std::string& FormattedRuleResults::localized_rule_name() const {
  return *localized_rule_name_;
}
inline void FormattedRuleResults::set_localized_rule_name(const ::std::string& value) {
  set_has_localized_rule_name();
  if (localized_rule_name_ == &::google::protobuf::internal::kEmptyString) {
    localized_rule_name_ = new ::std::string;
  }
  localized_rule_name_->assign(value);
}
inline void FormattedRuleResults::set_localized_rule_name(const char* value) {
  set_has_localized_rule_name();
  if (localized_rule_name_ == &::google::protobuf::internal::kEmptyString) {
    localized_rule_name_ = new ::std::string;
  }
  localized_rule_name_->assign(value);
}
inline void FormattedRuleResults::set_localized_rule_name(const char* value, size_t size) {
  set_has_localized_rule_name();
  if (localized_rule_name_ == &::google::protobuf::internal::kEmptyString) {
    localized_rule_name_ = new ::std::string;
  }
  localized_rule_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormattedRuleResults::mutable_localized_rule_name() {
  set_has_localized_rule_name();
  if (localized_rule_name_ == &::google::protobuf::internal::kEmptyString) {
    localized_rule_name_ = new ::std::string;
  }
  return localized_rule_name_;
}
inline ::std::string* FormattedRuleResults::release_localized_rule_name() {
  clear_has_localized_rule_name();
  if (localized_rule_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localized_rule_name_;
    localized_rule_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .pagespeed.FormattedUrlBlockResults url_blocks = 3;
inline int FormattedRuleResults::url_blocks_size() const {
  return url_blocks_.size();
}
inline void FormattedRuleResults::clear_url_blocks() {
  url_blocks_.Clear();
}
inline const ::pagespeed::FormattedUrlBlockResults& FormattedRuleResults::url_blocks(int index) const {
  return url_blocks_.Get(index);
}
inline ::pagespeed::FormattedUrlBlockResults* FormattedRuleResults::mutable_url_blocks(int index) {
  return url_blocks_.Mutable(index);
}
inline ::pagespeed::FormattedUrlBlockResults* FormattedRuleResults::add_url_blocks() {
  return url_blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedUrlBlockResults >&
FormattedRuleResults::url_blocks() const {
  return url_blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedUrlBlockResults >*
FormattedRuleResults::mutable_url_blocks() {
  return &url_blocks_;
}

// optional int32 rule_score = 4;
inline bool FormattedRuleResults::has_rule_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FormattedRuleResults::set_has_rule_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FormattedRuleResults::clear_has_rule_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FormattedRuleResults::clear_rule_score() {
  rule_score_ = 0;
  clear_has_rule_score();
}
inline ::google::protobuf::int32 FormattedRuleResults::rule_score() const {
  return rule_score_;
}
inline void FormattedRuleResults::set_rule_score(::google::protobuf::int32 value) {
  set_has_rule_score();
  rule_score_ = value;
}

// optional double rule_impact = 5;
inline bool FormattedRuleResults::has_rule_impact() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FormattedRuleResults::set_has_rule_impact() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FormattedRuleResults::clear_has_rule_impact() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FormattedRuleResults::clear_rule_impact() {
  rule_impact_ = 0;
  clear_has_rule_impact();
}
inline double FormattedRuleResults::rule_impact() const {
  return rule_impact_;
}
inline void FormattedRuleResults::set_rule_impact(double value) {
  set_has_rule_impact();
  rule_impact_ = value;
}

// optional bool experimental = 6;
inline bool FormattedRuleResults::has_experimental() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FormattedRuleResults::set_has_experimental() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FormattedRuleResults::clear_has_experimental() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FormattedRuleResults::clear_experimental() {
  experimental_ = false;
  clear_has_experimental();
}
inline bool FormattedRuleResults::experimental() const {
  return experimental_;
}
inline void FormattedRuleResults::set_experimental(bool value) {
  set_has_experimental();
  experimental_ = value;
}

// -------------------------------------------------------------------

// FormattedResults

// required string locale = 1;
inline bool FormattedResults::has_locale() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormattedResults::set_has_locale() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormattedResults::clear_has_locale() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormattedResults::clear_locale() {
  if (locale_ != &::google::protobuf::internal::kEmptyString) {
    locale_->clear();
  }
  clear_has_locale();
}
inline const ::std::string& FormattedResults::locale() const {
  return *locale_;
}
inline void FormattedResults::set_locale(const ::std::string& value) {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  locale_->assign(value);
}
inline void FormattedResults::set_locale(const char* value) {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  locale_->assign(value);
}
inline void FormattedResults::set_locale(const char* value, size_t size) {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  locale_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormattedResults::mutable_locale() {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  return locale_;
}
inline ::std::string* FormattedResults::release_locale() {
  clear_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = locale_;
    locale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .pagespeed.FormattedRuleResults rule_results = 2;
inline int FormattedResults::rule_results_size() const {
  return rule_results_.size();
}
inline void FormattedResults::clear_rule_results() {
  rule_results_.Clear();
}
inline const ::pagespeed::FormattedRuleResults& FormattedResults::rule_results(int index) const {
  return rule_results_.Get(index);
}
inline ::pagespeed::FormattedRuleResults* FormattedResults::mutable_rule_results(int index) {
  return rule_results_.Mutable(index);
}
inline ::pagespeed::FormattedRuleResults* FormattedResults::add_rule_results() {
  return rule_results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedRuleResults >&
FormattedResults::rule_results() const {
  return rule_results_;
}
inline ::google::protobuf::RepeatedPtrField< ::pagespeed::FormattedRuleResults >*
FormattedResults::mutable_rule_results() {
  return &rule_results_;
}

// optional int32 score = 3;
inline bool FormattedResults::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormattedResults::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormattedResults::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FormattedResults::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 FormattedResults::score() const {
  return score_;
}
inline void FormattedResults::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pagespeed

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pagespeed_5fproto_5fformatter_2eproto__INCLUDED
