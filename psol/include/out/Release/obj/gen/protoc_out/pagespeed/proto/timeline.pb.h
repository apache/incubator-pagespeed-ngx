// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: timeline.proto

#ifndef PROTOBUF_timeline_2eproto__INCLUDED
#define PROTOBUF_timeline_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace pagespeed {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_timeline_2eproto();
void protobuf_AssignDesc_timeline_2eproto();
void protobuf_ShutdownFile_timeline_2eproto();

class StackFrame;
class InstrumentationData;
class InstrumentationData_DataDictionary;

enum InstrumentationData_RecordType {
  InstrumentationData_RecordType_EVENT_DISPATCH = 0,
  InstrumentationData_RecordType_LAYOUT = 1,
  InstrumentationData_RecordType_RECALCULATE_STYLES = 2,
  InstrumentationData_RecordType_PAINT = 3,
  InstrumentationData_RecordType_PARSE_HTML = 4,
  InstrumentationData_RecordType_TIMER_INSTALL = 5,
  InstrumentationData_RecordType_TIMER_REMOVE = 6,
  InstrumentationData_RecordType_TIMER_FIRE = 7,
  InstrumentationData_RecordType_XHR_READY_STATE_CHANGE = 8,
  InstrumentationData_RecordType_XHR_LOAD = 9,
  InstrumentationData_RecordType_EVALUATE_SCRIPT = 10,
  InstrumentationData_RecordType_MARK_TIMELINE = 11,
  InstrumentationData_RecordType_RESOURCE_SEND_REQUEST = 12,
  InstrumentationData_RecordType_RESOURCE_RECEIVE_RESPONSE = 13,
  InstrumentationData_RecordType_RESOURCE_FINISH = 14,
  InstrumentationData_RecordType_FUNCTION_CALL = 15,
  InstrumentationData_RecordType_RESOURCE_RECEIVED_DATA = 16,
  InstrumentationData_RecordType_GC_EVENT = 17,
  InstrumentationData_RecordType_MARK_DOM_CONTENT = 18,
  InstrumentationData_RecordType_MARK_LOAD = 19,
  InstrumentationData_RecordType_SCHEDULE_RESOURCE_REQUEST = 20,
  InstrumentationData_RecordType_TIME_STAMP = 21,
  InstrumentationData_RecordType_REGISTER_ANIMATION_FRAME_CALLBACK = 22,
  InstrumentationData_RecordType_CANCEL_ANIMATION_FRAME_CALLBACK = 23,
  InstrumentationData_RecordType_FIRE_ANIMATION_FRAME_EVENT = 24,
  InstrumentationData_RecordType_BEGIN_FRAME = 25,
  InstrumentationData_RecordType_PROGRAM = 26,
  InstrumentationData_RecordType_COMPOSITE_LAYERS = 27,
  InstrumentationData_RecordType_TIME = 28,
  InstrumentationData_RecordType_TIME_END = 29
};
bool InstrumentationData_RecordType_IsValid(int value);
const InstrumentationData_RecordType InstrumentationData_RecordType_RecordType_MIN = InstrumentationData_RecordType_EVENT_DISPATCH;
const InstrumentationData_RecordType InstrumentationData_RecordType_RecordType_MAX = InstrumentationData_RecordType_TIME_END;
const int InstrumentationData_RecordType_RecordType_ARRAYSIZE = InstrumentationData_RecordType_RecordType_MAX + 1;

// ===================================================================

class StackFrame : public ::google::protobuf::MessageLite {
 public:
  StackFrame();
  virtual ~StackFrame();
  
  StackFrame(const StackFrame& from);
  
  inline StackFrame& operator=(const StackFrame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const StackFrame& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StackFrame* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(StackFrame* other);
  
  // implements Message ----------------------------------------------
  
  StackFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StackFrame& from);
  void MergeFrom(const StackFrame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // optional int32 line_number = 2;
  inline bool has_line_number() const;
  inline void clear_line_number();
  static const int kLineNumberFieldNumber = 2;
  inline ::google::protobuf::int32 line_number() const;
  inline void set_line_number(::google::protobuf::int32 value);
  
  // optional int32 column_number = 3;
  inline bool has_column_number() const;
  inline void clear_column_number();
  static const int kColumnNumberFieldNumber = 3;
  inline ::google::protobuf::int32 column_number() const;
  inline void set_column_number(::google::protobuf::int32 value);
  
  // optional string function_name = 4;
  inline bool has_function_name() const;
  inline void clear_function_name();
  static const int kFunctionNameFieldNumber = 4;
  inline const ::std::string& function_name() const;
  inline void set_function_name(const ::std::string& value);
  inline void set_function_name(const char* value);
  inline void set_function_name(const char* value, size_t size);
  inline ::std::string* mutable_function_name();
  inline ::std::string* release_function_name();
  
  // @@protoc_insertion_point(class_scope:pagespeed.StackFrame)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_line_number();
  inline void clear_has_line_number();
  inline void set_has_column_number();
  inline void clear_has_column_number();
  inline void set_has_function_name();
  inline void clear_has_function_name();
  
  ::std::string* url_;
  ::google::protobuf::int32 line_number_;
  ::google::protobuf::int32 column_number_;
  ::std::string* function_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_timeline_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_timeline_2eproto();
  #endif
  friend void protobuf_AssignDesc_timeline_2eproto();
  friend void protobuf_ShutdownFile_timeline_2eproto();
  
  void InitAsDefaultInstance();
  static StackFrame* default_instance_;
};
// -------------------------------------------------------------------

class InstrumentationData_DataDictionary : public ::google::protobuf::MessageLite {
 public:
  InstrumentationData_DataDictionary();
  virtual ~InstrumentationData_DataDictionary();
  
  InstrumentationData_DataDictionary(const InstrumentationData_DataDictionary& from);
  
  inline InstrumentationData_DataDictionary& operator=(const InstrumentationData_DataDictionary& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const InstrumentationData_DataDictionary& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstrumentationData_DataDictionary* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(InstrumentationData_DataDictionary* other);
  
  // implements Message ----------------------------------------------
  
  InstrumentationData_DataDictionary* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstrumentationData_DataDictionary& from);
  void MergeFrom(const InstrumentationData_DataDictionary& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 length = 1;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 1;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);
  
  // optional int32 start_line = 2;
  inline bool has_start_line() const;
  inline void clear_start_line();
  static const int kStartLineFieldNumber = 2;
  inline ::google::protobuf::int32 start_line() const;
  inline void set_start_line(::google::protobuf::int32 value);
  
  // optional int32 end_line = 3;
  inline bool has_end_line() const;
  inline void clear_end_line();
  static const int kEndLineFieldNumber = 3;
  inline ::google::protobuf::int32 end_line() const;
  inline void set_end_line(::google::protobuf::int32 value);
  
  // optional int32 used_heap_size_delta = 4;
  inline bool has_used_heap_size_delta() const;
  inline void clear_used_heap_size_delta();
  static const int kUsedHeapSizeDeltaFieldNumber = 4;
  inline ::google::protobuf::int32 used_heap_size_delta() const;
  inline void set_used_heap_size_delta(::google::protobuf::int32 value);
  
  // optional string script_name = 5;
  inline bool has_script_name() const;
  inline void clear_script_name();
  static const int kScriptNameFieldNumber = 5;
  inline const ::std::string& script_name() const;
  inline void set_script_name(const ::std::string& value);
  inline void set_script_name(const char* value);
  inline void set_script_name(const char* value, size_t size);
  inline ::std::string* mutable_script_name();
  inline ::std::string* release_script_name();
  
  // optional int32 script_line = 6;
  inline bool has_script_line() const;
  inline void clear_script_line();
  static const int kScriptLineFieldNumber = 6;
  inline ::google::protobuf::int32 script_line() const;
  inline void set_script_line(::google::protobuf::int32 value);
  
  // optional string type = 7;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 7;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  
  // optional int32 timer_id = 8;
  inline bool has_timer_id() const;
  inline void clear_timer_id();
  static const int kTimerIdFieldNumber = 8;
  inline ::google::protobuf::int32 timer_id() const;
  inline void set_timer_id(::google::protobuf::int32 value);
  
  // optional int32 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);
  
  // optional bool single_shot = 10;
  inline bool has_single_shot() const;
  inline void clear_single_shot();
  static const int kSingleShotFieldNumber = 10;
  inline bool single_shot() const;
  inline void set_single_shot(bool value);
  
  // optional string url = 11;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 11;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // optional int32 ready_state = 12;
  inline bool has_ready_state() const;
  inline void clear_ready_state();
  static const int kReadyStateFieldNumber = 12;
  inline ::google::protobuf::int32 ready_state() const;
  inline void set_ready_state(::google::protobuf::int32 value);
  
  // optional int32 line_number = 13;
  inline bool has_line_number() const;
  inline void clear_line_number();
  static const int kLineNumberFieldNumber = 13;
  inline ::google::protobuf::int32 line_number() const;
  inline void set_line_number(::google::protobuf::int32 value);
  
  // optional string message = 14;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 14;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // optional int32 identifier = 15 [deprecated = true];
  inline bool has_identifier() const PROTOBUF_DEPRECATED;
  inline void clear_identifier() PROTOBUF_DEPRECATED;
  static const int kIdentifierFieldNumber = 15;
  inline ::google::protobuf::int32 identifier() const PROTOBUF_DEPRECATED;
  inline void set_identifier(::google::protobuf::int32 value) PROTOBUF_DEPRECATED;
  
  // optional string request_method = 16;
  inline bool has_request_method() const;
  inline void clear_request_method();
  static const int kRequestMethodFieldNumber = 16;
  inline const ::std::string& request_method() const;
  inline void set_request_method(const ::std::string& value);
  inline void set_request_method(const char* value);
  inline void set_request_method(const char* value, size_t size);
  inline ::std::string* mutable_request_method();
  inline ::std::string* release_request_method();
  
  // optional bool is_main_resource = 17 [deprecated = true];
  inline bool has_is_main_resource() const PROTOBUF_DEPRECATED;
  inline void clear_is_main_resource() PROTOBUF_DEPRECATED;
  static const int kIsMainResourceFieldNumber = 17;
  inline bool is_main_resource() const PROTOBUF_DEPRECATED;
  inline void set_is_main_resource(bool value) PROTOBUF_DEPRECATED;
  
  // optional int32 status_code = 18;
  inline bool has_status_code() const;
  inline void clear_status_code();
  static const int kStatusCodeFieldNumber = 18;
  inline ::google::protobuf::int32 status_code() const;
  inline void set_status_code(::google::protobuf::int32 value);
  
  // optional string mime_type = 19;
  inline bool has_mime_type() const;
  inline void clear_mime_type();
  static const int kMimeTypeFieldNumber = 19;
  inline const ::std::string& mime_type() const;
  inline void set_mime_type(const ::std::string& value);
  inline void set_mime_type(const char* value);
  inline void set_mime_type(const char* value, size_t size);
  inline ::std::string* mutable_mime_type();
  inline ::std::string* release_mime_type();
  
  // optional int32 expected_content_length = 20 [deprecated = true];
  inline bool has_expected_content_length() const PROTOBUF_DEPRECATED;
  inline void clear_expected_content_length() PROTOBUF_DEPRECATED;
  static const int kExpectedContentLengthFieldNumber = 20;
  inline ::google::protobuf::int32 expected_content_length() const PROTOBUF_DEPRECATED;
  inline void set_expected_content_length(::google::protobuf::int32 value) PROTOBUF_DEPRECATED;
  
  // optional bool did_fail = 21;
  inline bool has_did_fail() const;
  inline void clear_did_fail();
  static const int kDidFailFieldNumber = 21;
  inline bool did_fail() const;
  inline void set_did_fail(bool value);
  
  // optional double network_time = 22;
  inline bool has_network_time() const;
  inline void clear_network_time();
  static const int kNetworkTimeFieldNumber = 22;
  inline double network_time() const;
  inline void set_network_time(double value);
  
  // optional int32 x = 23;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 23;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // optional int32 y = 24;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 24;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // optional int32 width = 25;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 25;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // optional int32 height = 26;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 26;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // optional string request_id = 27;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 27;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  
  // optional int32 id = 28;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 28;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 encoded_data_length = 29;
  inline bool has_encoded_data_length() const;
  inline void clear_encoded_data_length();
  static const int kEncodedDataLengthFieldNumber = 29;
  inline ::google::protobuf::int32 encoded_data_length() const;
  inline void set_encoded_data_length(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pagespeed.InstrumentationData.DataDictionary)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_start_line();
  inline void clear_has_start_line();
  inline void set_has_end_line();
  inline void clear_has_end_line();
  inline void set_has_used_heap_size_delta();
  inline void clear_has_used_heap_size_delta();
  inline void set_has_script_name();
  inline void clear_has_script_name();
  inline void set_has_script_line();
  inline void clear_has_script_line();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_timer_id();
  inline void clear_has_timer_id();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_single_shot();
  inline void clear_has_single_shot();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_ready_state();
  inline void clear_has_ready_state();
  inline void set_has_line_number();
  inline void clear_has_line_number();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_request_method();
  inline void clear_has_request_method();
  inline void set_has_is_main_resource();
  inline void clear_has_is_main_resource();
  inline void set_has_status_code();
  inline void clear_has_status_code();
  inline void set_has_mime_type();
  inline void clear_has_mime_type();
  inline void set_has_expected_content_length();
  inline void clear_has_expected_content_length();
  inline void set_has_did_fail();
  inline void clear_has_did_fail();
  inline void set_has_network_time();
  inline void clear_has_network_time();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_encoded_data_length();
  inline void clear_has_encoded_data_length();
  
  ::google::protobuf::int32 length_;
  ::google::protobuf::int32 start_line_;
  ::google::protobuf::int32 end_line_;
  ::google::protobuf::int32 used_heap_size_delta_;
  ::std::string* script_name_;
  ::std::string* type_;
  ::google::protobuf::int32 script_line_;
  ::google::protobuf::int32 timer_id_;
  ::google::protobuf::int32 timeout_;
  ::google::protobuf::int32 ready_state_;
  ::std::string* url_;
  ::std::string* message_;
  ::google::protobuf::int32 line_number_;
  ::google::protobuf::int32 identifier_;
  ::std::string* request_method_;
  bool single_shot_;
  bool is_main_resource_;
  bool did_fail_;
  ::google::protobuf::int32 status_code_;
  ::std::string* mime_type_;
  ::google::protobuf::int32 expected_content_length_;
  ::google::protobuf::int32 x_;
  double network_time_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 width_;
  ::std::string* request_id_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 encoded_data_length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(29 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_timeline_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_timeline_2eproto();
  #endif
  friend void protobuf_AssignDesc_timeline_2eproto();
  friend void protobuf_ShutdownFile_timeline_2eproto();
  
  void InitAsDefaultInstance();
  static InstrumentationData_DataDictionary* default_instance_;
};
// -------------------------------------------------------------------

class InstrumentationData : public ::google::protobuf::MessageLite {
 public:
  InstrumentationData();
  virtual ~InstrumentationData();
  
  InstrumentationData(const InstrumentationData& from);
  
  inline InstrumentationData& operator=(const InstrumentationData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const InstrumentationData& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstrumentationData* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(InstrumentationData* other);
  
  // implements Message ----------------------------------------------
  
  InstrumentationData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstrumentationData& from);
  void MergeFrom(const InstrumentationData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef InstrumentationData_DataDictionary DataDictionary;
  
  typedef InstrumentationData_RecordType RecordType;
  static const RecordType EVENT_DISPATCH = InstrumentationData_RecordType_EVENT_DISPATCH;
  static const RecordType LAYOUT = InstrumentationData_RecordType_LAYOUT;
  static const RecordType RECALCULATE_STYLES = InstrumentationData_RecordType_RECALCULATE_STYLES;
  static const RecordType PAINT = InstrumentationData_RecordType_PAINT;
  static const RecordType PARSE_HTML = InstrumentationData_RecordType_PARSE_HTML;
  static const RecordType TIMER_INSTALL = InstrumentationData_RecordType_TIMER_INSTALL;
  static const RecordType TIMER_REMOVE = InstrumentationData_RecordType_TIMER_REMOVE;
  static const RecordType TIMER_FIRE = InstrumentationData_RecordType_TIMER_FIRE;
  static const RecordType XHR_READY_STATE_CHANGE = InstrumentationData_RecordType_XHR_READY_STATE_CHANGE;
  static const RecordType XHR_LOAD = InstrumentationData_RecordType_XHR_LOAD;
  static const RecordType EVALUATE_SCRIPT = InstrumentationData_RecordType_EVALUATE_SCRIPT;
  static const RecordType MARK_TIMELINE = InstrumentationData_RecordType_MARK_TIMELINE;
  static const RecordType RESOURCE_SEND_REQUEST = InstrumentationData_RecordType_RESOURCE_SEND_REQUEST;
  static const RecordType RESOURCE_RECEIVE_RESPONSE = InstrumentationData_RecordType_RESOURCE_RECEIVE_RESPONSE;
  static const RecordType RESOURCE_FINISH = InstrumentationData_RecordType_RESOURCE_FINISH;
  static const RecordType FUNCTION_CALL = InstrumentationData_RecordType_FUNCTION_CALL;
  static const RecordType RESOURCE_RECEIVED_DATA = InstrumentationData_RecordType_RESOURCE_RECEIVED_DATA;
  static const RecordType GC_EVENT = InstrumentationData_RecordType_GC_EVENT;
  static const RecordType MARK_DOM_CONTENT = InstrumentationData_RecordType_MARK_DOM_CONTENT;
  static const RecordType MARK_LOAD = InstrumentationData_RecordType_MARK_LOAD;
  static const RecordType SCHEDULE_RESOURCE_REQUEST = InstrumentationData_RecordType_SCHEDULE_RESOURCE_REQUEST;
  static const RecordType TIME_STAMP = InstrumentationData_RecordType_TIME_STAMP;
  static const RecordType REGISTER_ANIMATION_FRAME_CALLBACK = InstrumentationData_RecordType_REGISTER_ANIMATION_FRAME_CALLBACK;
  static const RecordType CANCEL_ANIMATION_FRAME_CALLBACK = InstrumentationData_RecordType_CANCEL_ANIMATION_FRAME_CALLBACK;
  static const RecordType FIRE_ANIMATION_FRAME_EVENT = InstrumentationData_RecordType_FIRE_ANIMATION_FRAME_EVENT;
  static const RecordType BEGIN_FRAME = InstrumentationData_RecordType_BEGIN_FRAME;
  static const RecordType PROGRAM = InstrumentationData_RecordType_PROGRAM;
  static const RecordType COMPOSITE_LAYERS = InstrumentationData_RecordType_COMPOSITE_LAYERS;
  static const RecordType TIME = InstrumentationData_RecordType_TIME;
  static const RecordType TIME_END = InstrumentationData_RecordType_TIME_END;
  static inline bool RecordType_IsValid(int value) {
    return InstrumentationData_RecordType_IsValid(value);
  }
  static const RecordType RecordType_MIN =
    InstrumentationData_RecordType_RecordType_MIN;
  static const RecordType RecordType_MAX =
    InstrumentationData_RecordType_RecordType_MAX;
  static const int RecordType_ARRAYSIZE =
    InstrumentationData_RecordType_RecordType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional .pagespeed.InstrumentationData.RecordType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pagespeed::InstrumentationData_RecordType type() const;
  inline void set_type(::pagespeed::InstrumentationData_RecordType value);
  
  // repeated .pagespeed.InstrumentationData children = 2;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 2;
  inline const ::pagespeed::InstrumentationData& children(int index) const;
  inline ::pagespeed::InstrumentationData* mutable_children(int index);
  inline ::pagespeed::InstrumentationData* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::pagespeed::InstrumentationData >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::pagespeed::InstrumentationData >*
      mutable_children();
  
  // repeated .pagespeed.StackFrame stack_trace = 3;
  inline int stack_trace_size() const;
  inline void clear_stack_trace();
  static const int kStackTraceFieldNumber = 3;
  inline const ::pagespeed::StackFrame& stack_trace(int index) const;
  inline ::pagespeed::StackFrame* mutable_stack_trace(int index);
  inline ::pagespeed::StackFrame* add_stack_trace();
  inline const ::google::protobuf::RepeatedPtrField< ::pagespeed::StackFrame >&
      stack_trace() const;
  inline ::google::protobuf::RepeatedPtrField< ::pagespeed::StackFrame >*
      mutable_stack_trace();
  
  // optional .pagespeed.InstrumentationData.DataDictionary data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::pagespeed::InstrumentationData_DataDictionary& data() const;
  inline ::pagespeed::InstrumentationData_DataDictionary* mutable_data();
  inline ::pagespeed::InstrumentationData_DataDictionary* release_data();
  
  // optional double start_time = 5;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 5;
  inline double start_time() const;
  inline void set_start_time(double value);
  
  // optional double end_time = 6;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 6;
  inline double end_time() const;
  inline void set_end_time(double value);
  
  // optional int64 used_heap_size = 7;
  inline bool has_used_heap_size() const;
  inline void clear_used_heap_size();
  static const int kUsedHeapSizeFieldNumber = 7;
  inline ::google::protobuf::int64 used_heap_size() const;
  inline void set_used_heap_size(::google::protobuf::int64 value);
  
  // optional int64 total_heap_size = 8;
  inline bool has_total_heap_size() const;
  inline void clear_total_heap_size();
  static const int kTotalHeapSizeFieldNumber = 8;
  inline ::google::protobuf::int64 total_heap_size() const;
  inline void set_total_heap_size(::google::protobuf::int64 value);
  
  // optional int64 start_tick = 9;
  inline bool has_start_tick() const;
  inline void clear_start_tick();
  static const int kStartTickFieldNumber = 9;
  inline ::google::protobuf::int64 start_tick() const;
  inline void set_start_tick(::google::protobuf::int64 value);
  
  // optional int64 end_tick = 10;
  inline bool has_end_tick() const;
  inline void clear_end_tick();
  static const int kEndTickFieldNumber = 10;
  inline ::google::protobuf::int64 end_tick() const;
  inline void set_end_tick(::google::protobuf::int64 value);
  
  // optional string context_id = 11;
  inline bool has_context_id() const;
  inline void clear_context_id();
  static const int kContextIdFieldNumber = 11;
  inline const ::std::string& context_id() const;
  inline void set_context_id(const ::std::string& value);
  inline void set_context_id(const char* value);
  inline void set_context_id(const char* value, size_t size);
  inline ::std::string* mutable_context_id();
  inline ::std::string* release_context_id();
  
  // @@protoc_insertion_point(class_scope:pagespeed.InstrumentationData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_used_heap_size();
  inline void clear_has_used_heap_size();
  inline void set_has_total_heap_size();
  inline void clear_has_total_heap_size();
  inline void set_has_start_tick();
  inline void clear_has_start_tick();
  inline void set_has_end_tick();
  inline void clear_has_end_tick();
  inline void set_has_context_id();
  inline void clear_has_context_id();
  
  ::google::protobuf::RepeatedPtrField< ::pagespeed::InstrumentationData > children_;
  ::google::protobuf::RepeatedPtrField< ::pagespeed::StackFrame > stack_trace_;
  ::pagespeed::InstrumentationData_DataDictionary* data_;
  double start_time_;
  double end_time_;
  ::google::protobuf::int64 used_heap_size_;
  ::google::protobuf::int64 total_heap_size_;
  ::google::protobuf::int64 start_tick_;
  ::google::protobuf::int64 end_tick_;
  ::std::string* context_id_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_timeline_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_timeline_2eproto();
  #endif
  friend void protobuf_AssignDesc_timeline_2eproto();
  friend void protobuf_ShutdownFile_timeline_2eproto();
  
  void InitAsDefaultInstance();
  static InstrumentationData* default_instance_;
};
// ===================================================================


// ===================================================================

// StackFrame

// optional string url = 1;
inline bool StackFrame::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StackFrame::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StackFrame::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StackFrame::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& StackFrame::url() const {
  return *url_;
}
inline void StackFrame::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void StackFrame::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void StackFrame::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StackFrame::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* StackFrame::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 line_number = 2;
inline bool StackFrame::has_line_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StackFrame::set_has_line_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StackFrame::clear_has_line_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StackFrame::clear_line_number() {
  line_number_ = 0;
  clear_has_line_number();
}
inline ::google::protobuf::int32 StackFrame::line_number() const {
  return line_number_;
}
inline void StackFrame::set_line_number(::google::protobuf::int32 value) {
  set_has_line_number();
  line_number_ = value;
}

// optional int32 column_number = 3;
inline bool StackFrame::has_column_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StackFrame::set_has_column_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StackFrame::clear_has_column_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StackFrame::clear_column_number() {
  column_number_ = 0;
  clear_has_column_number();
}
inline ::google::protobuf::int32 StackFrame::column_number() const {
  return column_number_;
}
inline void StackFrame::set_column_number(::google::protobuf::int32 value) {
  set_has_column_number();
  column_number_ = value;
}

// optional string function_name = 4;
inline bool StackFrame::has_function_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StackFrame::set_has_function_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StackFrame::clear_has_function_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StackFrame::clear_function_name() {
  if (function_name_ != &::google::protobuf::internal::kEmptyString) {
    function_name_->clear();
  }
  clear_has_function_name();
}
inline const ::std::string& StackFrame::function_name() const {
  return *function_name_;
}
inline void StackFrame::set_function_name(const ::std::string& value) {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::kEmptyString) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(value);
}
inline void StackFrame::set_function_name(const char* value) {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::kEmptyString) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(value);
}
inline void StackFrame::set_function_name(const char* value, size_t size) {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::kEmptyString) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StackFrame::mutable_function_name() {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::kEmptyString) {
    function_name_ = new ::std::string;
  }
  return function_name_;
}
inline ::std::string* StackFrame::release_function_name() {
  clear_has_function_name();
  if (function_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = function_name_;
    function_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// InstrumentationData_DataDictionary

// optional int32 length = 1;
inline bool InstrumentationData_DataDictionary::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstrumentationData_DataDictionary::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstrumentationData_DataDictionary::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::length() const {
  return length_;
}
inline void InstrumentationData_DataDictionary::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// optional int32 start_line = 2;
inline bool InstrumentationData_DataDictionary::has_start_line() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_start_line() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstrumentationData_DataDictionary::clear_has_start_line() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstrumentationData_DataDictionary::clear_start_line() {
  start_line_ = 0;
  clear_has_start_line();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::start_line() const {
  return start_line_;
}
inline void InstrumentationData_DataDictionary::set_start_line(::google::protobuf::int32 value) {
  set_has_start_line();
  start_line_ = value;
}

// optional int32 end_line = 3;
inline bool InstrumentationData_DataDictionary::has_end_line() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_end_line() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstrumentationData_DataDictionary::clear_has_end_line() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstrumentationData_DataDictionary::clear_end_line() {
  end_line_ = 0;
  clear_has_end_line();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::end_line() const {
  return end_line_;
}
inline void InstrumentationData_DataDictionary::set_end_line(::google::protobuf::int32 value) {
  set_has_end_line();
  end_line_ = value;
}

// optional int32 used_heap_size_delta = 4;
inline bool InstrumentationData_DataDictionary::has_used_heap_size_delta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_used_heap_size_delta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstrumentationData_DataDictionary::clear_has_used_heap_size_delta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstrumentationData_DataDictionary::clear_used_heap_size_delta() {
  used_heap_size_delta_ = 0;
  clear_has_used_heap_size_delta();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::used_heap_size_delta() const {
  return used_heap_size_delta_;
}
inline void InstrumentationData_DataDictionary::set_used_heap_size_delta(::google::protobuf::int32 value) {
  set_has_used_heap_size_delta();
  used_heap_size_delta_ = value;
}

// optional string script_name = 5;
inline bool InstrumentationData_DataDictionary::has_script_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_script_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstrumentationData_DataDictionary::clear_has_script_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstrumentationData_DataDictionary::clear_script_name() {
  if (script_name_ != &::google::protobuf::internal::kEmptyString) {
    script_name_->clear();
  }
  clear_has_script_name();
}
inline const ::std::string& InstrumentationData_DataDictionary::script_name() const {
  return *script_name_;
}
inline void InstrumentationData_DataDictionary::set_script_name(const ::std::string& value) {
  set_has_script_name();
  if (script_name_ == &::google::protobuf::internal::kEmptyString) {
    script_name_ = new ::std::string;
  }
  script_name_->assign(value);
}
inline void InstrumentationData_DataDictionary::set_script_name(const char* value) {
  set_has_script_name();
  if (script_name_ == &::google::protobuf::internal::kEmptyString) {
    script_name_ = new ::std::string;
  }
  script_name_->assign(value);
}
inline void InstrumentationData_DataDictionary::set_script_name(const char* value, size_t size) {
  set_has_script_name();
  if (script_name_ == &::google::protobuf::internal::kEmptyString) {
    script_name_ = new ::std::string;
  }
  script_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentationData_DataDictionary::mutable_script_name() {
  set_has_script_name();
  if (script_name_ == &::google::protobuf::internal::kEmptyString) {
    script_name_ = new ::std::string;
  }
  return script_name_;
}
inline ::std::string* InstrumentationData_DataDictionary::release_script_name() {
  clear_has_script_name();
  if (script_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_name_;
    script_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 script_line = 6;
inline bool InstrumentationData_DataDictionary::has_script_line() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_script_line() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InstrumentationData_DataDictionary::clear_has_script_line() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InstrumentationData_DataDictionary::clear_script_line() {
  script_line_ = 0;
  clear_has_script_line();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::script_line() const {
  return script_line_;
}
inline void InstrumentationData_DataDictionary::set_script_line(::google::protobuf::int32 value) {
  set_has_script_line();
  script_line_ = value;
}

// optional string type = 7;
inline bool InstrumentationData_DataDictionary::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InstrumentationData_DataDictionary::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InstrumentationData_DataDictionary::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& InstrumentationData_DataDictionary::type() const {
  return *type_;
}
inline void InstrumentationData_DataDictionary::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void InstrumentationData_DataDictionary::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void InstrumentationData_DataDictionary::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentationData_DataDictionary::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* InstrumentationData_DataDictionary::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 timer_id = 8;
inline bool InstrumentationData_DataDictionary::has_timer_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_timer_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InstrumentationData_DataDictionary::clear_has_timer_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InstrumentationData_DataDictionary::clear_timer_id() {
  timer_id_ = 0;
  clear_has_timer_id();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::timer_id() const {
  return timer_id_;
}
inline void InstrumentationData_DataDictionary::set_timer_id(::google::protobuf::int32 value) {
  set_has_timer_id();
  timer_id_ = value;
}

// optional int32 timeout = 9;
inline bool InstrumentationData_DataDictionary::has_timeout() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_timeout() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InstrumentationData_DataDictionary::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InstrumentationData_DataDictionary::clear_timeout() {
  timeout_ = 0;
  clear_has_timeout();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::timeout() const {
  return timeout_;
}
inline void InstrumentationData_DataDictionary::set_timeout(::google::protobuf::int32 value) {
  set_has_timeout();
  timeout_ = value;
}

// optional bool single_shot = 10;
inline bool InstrumentationData_DataDictionary::has_single_shot() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_single_shot() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InstrumentationData_DataDictionary::clear_has_single_shot() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InstrumentationData_DataDictionary::clear_single_shot() {
  single_shot_ = false;
  clear_has_single_shot();
}
inline bool InstrumentationData_DataDictionary::single_shot() const {
  return single_shot_;
}
inline void InstrumentationData_DataDictionary::set_single_shot(bool value) {
  set_has_single_shot();
  single_shot_ = value;
}

// optional string url = 11;
inline bool InstrumentationData_DataDictionary::has_url() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_url() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InstrumentationData_DataDictionary::clear_has_url() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InstrumentationData_DataDictionary::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& InstrumentationData_DataDictionary::url() const {
  return *url_;
}
inline void InstrumentationData_DataDictionary::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void InstrumentationData_DataDictionary::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void InstrumentationData_DataDictionary::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentationData_DataDictionary::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* InstrumentationData_DataDictionary::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 ready_state = 12;
inline bool InstrumentationData_DataDictionary::has_ready_state() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_ready_state() {
  _has_bits_[0] |= 0x00000800u;
}
inline void InstrumentationData_DataDictionary::clear_has_ready_state() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void InstrumentationData_DataDictionary::clear_ready_state() {
  ready_state_ = 0;
  clear_has_ready_state();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::ready_state() const {
  return ready_state_;
}
inline void InstrumentationData_DataDictionary::set_ready_state(::google::protobuf::int32 value) {
  set_has_ready_state();
  ready_state_ = value;
}

// optional int32 line_number = 13;
inline bool InstrumentationData_DataDictionary::has_line_number() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_line_number() {
  _has_bits_[0] |= 0x00001000u;
}
inline void InstrumentationData_DataDictionary::clear_has_line_number() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void InstrumentationData_DataDictionary::clear_line_number() {
  line_number_ = 0;
  clear_has_line_number();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::line_number() const {
  return line_number_;
}
inline void InstrumentationData_DataDictionary::set_line_number(::google::protobuf::int32 value) {
  set_has_line_number();
  line_number_ = value;
}

// optional string message = 14;
inline bool InstrumentationData_DataDictionary::has_message() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_message() {
  _has_bits_[0] |= 0x00002000u;
}
inline void InstrumentationData_DataDictionary::clear_has_message() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void InstrumentationData_DataDictionary::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& InstrumentationData_DataDictionary::message() const {
  return *message_;
}
inline void InstrumentationData_DataDictionary::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void InstrumentationData_DataDictionary::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void InstrumentationData_DataDictionary::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentationData_DataDictionary::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* InstrumentationData_DataDictionary::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 identifier = 15 [deprecated = true];
inline bool InstrumentationData_DataDictionary::has_identifier() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_identifier() {
  _has_bits_[0] |= 0x00004000u;
}
inline void InstrumentationData_DataDictionary::clear_has_identifier() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void InstrumentationData_DataDictionary::clear_identifier() {
  identifier_ = 0;
  clear_has_identifier();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::identifier() const {
  return identifier_;
}
inline void InstrumentationData_DataDictionary::set_identifier(::google::protobuf::int32 value) {
  set_has_identifier();
  identifier_ = value;
}

// optional string request_method = 16;
inline bool InstrumentationData_DataDictionary::has_request_method() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_request_method() {
  _has_bits_[0] |= 0x00008000u;
}
inline void InstrumentationData_DataDictionary::clear_has_request_method() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void InstrumentationData_DataDictionary::clear_request_method() {
  if (request_method_ != &::google::protobuf::internal::kEmptyString) {
    request_method_->clear();
  }
  clear_has_request_method();
}
inline const ::std::string& InstrumentationData_DataDictionary::request_method() const {
  return *request_method_;
}
inline void InstrumentationData_DataDictionary::set_request_method(const ::std::string& value) {
  set_has_request_method();
  if (request_method_ == &::google::protobuf::internal::kEmptyString) {
    request_method_ = new ::std::string;
  }
  request_method_->assign(value);
}
inline void InstrumentationData_DataDictionary::set_request_method(const char* value) {
  set_has_request_method();
  if (request_method_ == &::google::protobuf::internal::kEmptyString) {
    request_method_ = new ::std::string;
  }
  request_method_->assign(value);
}
inline void InstrumentationData_DataDictionary::set_request_method(const char* value, size_t size) {
  set_has_request_method();
  if (request_method_ == &::google::protobuf::internal::kEmptyString) {
    request_method_ = new ::std::string;
  }
  request_method_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentationData_DataDictionary::mutable_request_method() {
  set_has_request_method();
  if (request_method_ == &::google::protobuf::internal::kEmptyString) {
    request_method_ = new ::std::string;
  }
  return request_method_;
}
inline ::std::string* InstrumentationData_DataDictionary::release_request_method() {
  clear_has_request_method();
  if (request_method_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_method_;
    request_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool is_main_resource = 17 [deprecated = true];
inline bool InstrumentationData_DataDictionary::has_is_main_resource() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_is_main_resource() {
  _has_bits_[0] |= 0x00010000u;
}
inline void InstrumentationData_DataDictionary::clear_has_is_main_resource() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void InstrumentationData_DataDictionary::clear_is_main_resource() {
  is_main_resource_ = false;
  clear_has_is_main_resource();
}
inline bool InstrumentationData_DataDictionary::is_main_resource() const {
  return is_main_resource_;
}
inline void InstrumentationData_DataDictionary::set_is_main_resource(bool value) {
  set_has_is_main_resource();
  is_main_resource_ = value;
}

// optional int32 status_code = 18;
inline bool InstrumentationData_DataDictionary::has_status_code() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_status_code() {
  _has_bits_[0] |= 0x00020000u;
}
inline void InstrumentationData_DataDictionary::clear_has_status_code() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void InstrumentationData_DataDictionary::clear_status_code() {
  status_code_ = 0;
  clear_has_status_code();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::status_code() const {
  return status_code_;
}
inline void InstrumentationData_DataDictionary::set_status_code(::google::protobuf::int32 value) {
  set_has_status_code();
  status_code_ = value;
}

// optional string mime_type = 19;
inline bool InstrumentationData_DataDictionary::has_mime_type() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_mime_type() {
  _has_bits_[0] |= 0x00040000u;
}
inline void InstrumentationData_DataDictionary::clear_has_mime_type() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void InstrumentationData_DataDictionary::clear_mime_type() {
  if (mime_type_ != &::google::protobuf::internal::kEmptyString) {
    mime_type_->clear();
  }
  clear_has_mime_type();
}
inline const ::std::string& InstrumentationData_DataDictionary::mime_type() const {
  return *mime_type_;
}
inline void InstrumentationData_DataDictionary::set_mime_type(const ::std::string& value) {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void InstrumentationData_DataDictionary::set_mime_type(const char* value) {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void InstrumentationData_DataDictionary::set_mime_type(const char* value, size_t size) {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentationData_DataDictionary::mutable_mime_type() {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  return mime_type_;
}
inline ::std::string* InstrumentationData_DataDictionary::release_mime_type() {
  clear_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mime_type_;
    mime_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 expected_content_length = 20 [deprecated = true];
inline bool InstrumentationData_DataDictionary::has_expected_content_length() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_expected_content_length() {
  _has_bits_[0] |= 0x00080000u;
}
inline void InstrumentationData_DataDictionary::clear_has_expected_content_length() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void InstrumentationData_DataDictionary::clear_expected_content_length() {
  expected_content_length_ = 0;
  clear_has_expected_content_length();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::expected_content_length() const {
  return expected_content_length_;
}
inline void InstrumentationData_DataDictionary::set_expected_content_length(::google::protobuf::int32 value) {
  set_has_expected_content_length();
  expected_content_length_ = value;
}

// optional bool did_fail = 21;
inline bool InstrumentationData_DataDictionary::has_did_fail() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_did_fail() {
  _has_bits_[0] |= 0x00100000u;
}
inline void InstrumentationData_DataDictionary::clear_has_did_fail() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void InstrumentationData_DataDictionary::clear_did_fail() {
  did_fail_ = false;
  clear_has_did_fail();
}
inline bool InstrumentationData_DataDictionary::did_fail() const {
  return did_fail_;
}
inline void InstrumentationData_DataDictionary::set_did_fail(bool value) {
  set_has_did_fail();
  did_fail_ = value;
}

// optional double network_time = 22;
inline bool InstrumentationData_DataDictionary::has_network_time() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_network_time() {
  _has_bits_[0] |= 0x00200000u;
}
inline void InstrumentationData_DataDictionary::clear_has_network_time() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void InstrumentationData_DataDictionary::clear_network_time() {
  network_time_ = 0;
  clear_has_network_time();
}
inline double InstrumentationData_DataDictionary::network_time() const {
  return network_time_;
}
inline void InstrumentationData_DataDictionary::set_network_time(double value) {
  set_has_network_time();
  network_time_ = value;
}

// optional int32 x = 23;
inline bool InstrumentationData_DataDictionary::has_x() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_x() {
  _has_bits_[0] |= 0x00400000u;
}
inline void InstrumentationData_DataDictionary::clear_has_x() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void InstrumentationData_DataDictionary::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::x() const {
  return x_;
}
inline void InstrumentationData_DataDictionary::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 24;
inline bool InstrumentationData_DataDictionary::has_y() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_y() {
  _has_bits_[0] |= 0x00800000u;
}
inline void InstrumentationData_DataDictionary::clear_has_y() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void InstrumentationData_DataDictionary::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::y() const {
  return y_;
}
inline void InstrumentationData_DataDictionary::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// optional int32 width = 25;
inline bool InstrumentationData_DataDictionary::has_width() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_width() {
  _has_bits_[0] |= 0x01000000u;
}
inline void InstrumentationData_DataDictionary::clear_has_width() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void InstrumentationData_DataDictionary::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::width() const {
  return width_;
}
inline void InstrumentationData_DataDictionary::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int32 height = 26;
inline bool InstrumentationData_DataDictionary::has_height() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_height() {
  _has_bits_[0] |= 0x02000000u;
}
inline void InstrumentationData_DataDictionary::clear_has_height() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void InstrumentationData_DataDictionary::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::height() const {
  return height_;
}
inline void InstrumentationData_DataDictionary::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional string request_id = 27;
inline bool InstrumentationData_DataDictionary::has_request_id() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_request_id() {
  _has_bits_[0] |= 0x04000000u;
}
inline void InstrumentationData_DataDictionary::clear_has_request_id() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void InstrumentationData_DataDictionary::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& InstrumentationData_DataDictionary::request_id() const {
  return *request_id_;
}
inline void InstrumentationData_DataDictionary::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void InstrumentationData_DataDictionary::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void InstrumentationData_DataDictionary::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentationData_DataDictionary::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* InstrumentationData_DataDictionary::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 id = 28;
inline bool InstrumentationData_DataDictionary::has_id() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_id() {
  _has_bits_[0] |= 0x08000000u;
}
inline void InstrumentationData_DataDictionary::clear_has_id() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void InstrumentationData_DataDictionary::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::id() const {
  return id_;
}
inline void InstrumentationData_DataDictionary::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 encoded_data_length = 29;
inline bool InstrumentationData_DataDictionary::has_encoded_data_length() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void InstrumentationData_DataDictionary::set_has_encoded_data_length() {
  _has_bits_[0] |= 0x10000000u;
}
inline void InstrumentationData_DataDictionary::clear_has_encoded_data_length() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void InstrumentationData_DataDictionary::clear_encoded_data_length() {
  encoded_data_length_ = 0;
  clear_has_encoded_data_length();
}
inline ::google::protobuf::int32 InstrumentationData_DataDictionary::encoded_data_length() const {
  return encoded_data_length_;
}
inline void InstrumentationData_DataDictionary::set_encoded_data_length(::google::protobuf::int32 value) {
  set_has_encoded_data_length();
  encoded_data_length_ = value;
}

// -------------------------------------------------------------------

// InstrumentationData

// optional .pagespeed.InstrumentationData.RecordType type = 1;
inline bool InstrumentationData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstrumentationData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstrumentationData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstrumentationData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pagespeed::InstrumentationData_RecordType InstrumentationData::type() const {
  return static_cast< ::pagespeed::InstrumentationData_RecordType >(type_);
}
inline void InstrumentationData::set_type(::pagespeed::InstrumentationData_RecordType value) {
  GOOGLE_DCHECK(::pagespeed::InstrumentationData_RecordType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .pagespeed.InstrumentationData children = 2;
inline int InstrumentationData::children_size() const {
  return children_.size();
}
inline void InstrumentationData::clear_children() {
  children_.Clear();
}
inline const ::pagespeed::InstrumentationData& InstrumentationData::children(int index) const {
  return children_.Get(index);
}
inline ::pagespeed::InstrumentationData* InstrumentationData::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::pagespeed::InstrumentationData* InstrumentationData::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pagespeed::InstrumentationData >&
InstrumentationData::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::pagespeed::InstrumentationData >*
InstrumentationData::mutable_children() {
  return &children_;
}

// repeated .pagespeed.StackFrame stack_trace = 3;
inline int InstrumentationData::stack_trace_size() const {
  return stack_trace_.size();
}
inline void InstrumentationData::clear_stack_trace() {
  stack_trace_.Clear();
}
inline const ::pagespeed::StackFrame& InstrumentationData::stack_trace(int index) const {
  return stack_trace_.Get(index);
}
inline ::pagespeed::StackFrame* InstrumentationData::mutable_stack_trace(int index) {
  return stack_trace_.Mutable(index);
}
inline ::pagespeed::StackFrame* InstrumentationData::add_stack_trace() {
  return stack_trace_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pagespeed::StackFrame >&
InstrumentationData::stack_trace() const {
  return stack_trace_;
}
inline ::google::protobuf::RepeatedPtrField< ::pagespeed::StackFrame >*
InstrumentationData::mutable_stack_trace() {
  return &stack_trace_;
}

// optional .pagespeed.InstrumentationData.DataDictionary data = 4;
inline bool InstrumentationData::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstrumentationData::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstrumentationData::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstrumentationData::clear_data() {
  if (data_ != NULL) data_->::pagespeed::InstrumentationData_DataDictionary::Clear();
  clear_has_data();
}
inline const ::pagespeed::InstrumentationData_DataDictionary& InstrumentationData::data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return data_ != NULL ? *data_ : *default_instance().data_;
#else
  return data_ != NULL ? *data_ : *default_instance_->data_;
#endif
}
inline ::pagespeed::InstrumentationData_DataDictionary* InstrumentationData::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::pagespeed::InstrumentationData_DataDictionary;
  return data_;
}
inline ::pagespeed::InstrumentationData_DataDictionary* InstrumentationData::release_data() {
  clear_has_data();
  ::pagespeed::InstrumentationData_DataDictionary* temp = data_;
  data_ = NULL;
  return temp;
}

// optional double start_time = 5;
inline bool InstrumentationData::has_start_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstrumentationData::set_has_start_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstrumentationData::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstrumentationData::clear_start_time() {
  start_time_ = 0;
  clear_has_start_time();
}
inline double InstrumentationData::start_time() const {
  return start_time_;
}
inline void InstrumentationData::set_start_time(double value) {
  set_has_start_time();
  start_time_ = value;
}

// optional double end_time = 6;
inline bool InstrumentationData::has_end_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InstrumentationData::set_has_end_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InstrumentationData::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InstrumentationData::clear_end_time() {
  end_time_ = 0;
  clear_has_end_time();
}
inline double InstrumentationData::end_time() const {
  return end_time_;
}
inline void InstrumentationData::set_end_time(double value) {
  set_has_end_time();
  end_time_ = value;
}

// optional int64 used_heap_size = 7;
inline bool InstrumentationData::has_used_heap_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InstrumentationData::set_has_used_heap_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InstrumentationData::clear_has_used_heap_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InstrumentationData::clear_used_heap_size() {
  used_heap_size_ = GOOGLE_LONGLONG(0);
  clear_has_used_heap_size();
}
inline ::google::protobuf::int64 InstrumentationData::used_heap_size() const {
  return used_heap_size_;
}
inline void InstrumentationData::set_used_heap_size(::google::protobuf::int64 value) {
  set_has_used_heap_size();
  used_heap_size_ = value;
}

// optional int64 total_heap_size = 8;
inline bool InstrumentationData::has_total_heap_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InstrumentationData::set_has_total_heap_size() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InstrumentationData::clear_has_total_heap_size() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InstrumentationData::clear_total_heap_size() {
  total_heap_size_ = GOOGLE_LONGLONG(0);
  clear_has_total_heap_size();
}
inline ::google::protobuf::int64 InstrumentationData::total_heap_size() const {
  return total_heap_size_;
}
inline void InstrumentationData::set_total_heap_size(::google::protobuf::int64 value) {
  set_has_total_heap_size();
  total_heap_size_ = value;
}

// optional int64 start_tick = 9;
inline bool InstrumentationData::has_start_tick() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InstrumentationData::set_has_start_tick() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InstrumentationData::clear_has_start_tick() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InstrumentationData::clear_start_tick() {
  start_tick_ = GOOGLE_LONGLONG(0);
  clear_has_start_tick();
}
inline ::google::protobuf::int64 InstrumentationData::start_tick() const {
  return start_tick_;
}
inline void InstrumentationData::set_start_tick(::google::protobuf::int64 value) {
  set_has_start_tick();
  start_tick_ = value;
}

// optional int64 end_tick = 10;
inline bool InstrumentationData::has_end_tick() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InstrumentationData::set_has_end_tick() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InstrumentationData::clear_has_end_tick() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InstrumentationData::clear_end_tick() {
  end_tick_ = GOOGLE_LONGLONG(0);
  clear_has_end_tick();
}
inline ::google::protobuf::int64 InstrumentationData::end_tick() const {
  return end_tick_;
}
inline void InstrumentationData::set_end_tick(::google::protobuf::int64 value) {
  set_has_end_tick();
  end_tick_ = value;
}

// optional string context_id = 11;
inline bool InstrumentationData::has_context_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InstrumentationData::set_has_context_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InstrumentationData::clear_has_context_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InstrumentationData::clear_context_id() {
  if (context_id_ != &::google::protobuf::internal::kEmptyString) {
    context_id_->clear();
  }
  clear_has_context_id();
}
inline const ::std::string& InstrumentationData::context_id() const {
  return *context_id_;
}
inline void InstrumentationData::set_context_id(const ::std::string& value) {
  set_has_context_id();
  if (context_id_ == &::google::protobuf::internal::kEmptyString) {
    context_id_ = new ::std::string;
  }
  context_id_->assign(value);
}
inline void InstrumentationData::set_context_id(const char* value) {
  set_has_context_id();
  if (context_id_ == &::google::protobuf::internal::kEmptyString) {
    context_id_ = new ::std::string;
  }
  context_id_->assign(value);
}
inline void InstrumentationData::set_context_id(const char* value, size_t size) {
  set_has_context_id();
  if (context_id_ == &::google::protobuf::internal::kEmptyString) {
    context_id_ = new ::std::string;
  }
  context_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentationData::mutable_context_id() {
  set_has_context_id();
  if (context_id_ == &::google::protobuf::internal::kEmptyString) {
    context_id_ = new ::std::string;
  }
  return context_id_;
}
inline ::std::string* InstrumentationData::release_context_id() {
  clear_has_context_id();
  if (context_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = context_id_;
    context_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pagespeed

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_timeline_2eproto__INCLUDED
