/*
 * Copyright 2013 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Author: Huibao Lin

#include "base/logging.h"
#include "pagespeed/kernel/base/gtest.h"
#include "pagespeed/kernel/base/string.h"
#include "pagespeed/kernel/image/png_optimizer.h"
#include "pagespeed/kernel/image/read_image.h"
#include "pagespeed/kernel/image/test_utils.h"
#include "pagespeed/kernel/image/webp_optimizer.h"

namespace {

using pagespeed::image_compression::IMAGE_PNG;
using pagespeed::image_compression::IMAGE_WEBP;
using pagespeed::image_compression::kPngSuiteTestDir;
using pagespeed::image_compression::kWebpTestDir;
using pagespeed::image_compression::PixelFormat;
using pagespeed::image_compression::PngScanlineReaderRaw;
using pagespeed::image_compression::ReadTestFile;
using pagespeed::image_compression::RGB_888;
using pagespeed::image_compression::RGBA_8888;
using pagespeed::image_compression::WebpConfiguration;
using pagespeed::image_compression::WebpScanlineReader;
using pagespeed::image_compression::WebpScanlineWriter;

// Each file in kValidImages is saved in both PNG format and WebP format.
// alpha_32x32.webp is lossless, while opaque_32x20.webp is lossy.
// alpha_32x32.png and opaque_32x20.png were generated by 'dwebp' from the
// corresponding WebP images.
const char* kValidImages[] = {
  "alpha_32x32",    // size 32-by-32 with alpha.
  "opaque_32x20",   // size 32-by-20 without alpha.
};
const size_t kValidImageCount = arraysize(kValidImages);

const char kFileCorruptedHeader[] = "corrupt_header";
const char kFileCorruptedBody[] = "corrupt_body";
const double kMinPSNR = 33.0;

class WebpScanlineReaderTest : public testing::Test {
 public:
  WebpScanlineReaderTest()
    : scanline_(NULL) {
  }

  bool Initialize(const char* file_name) {
    if (!ReadTestFile(kWebpTestDir, file_name, "webp", &input_image_)) {
      LOG(ERROR) << "Failed to read file: " << file_name;
      return false;
    }
    return reader_.Initialize(input_image_.c_str(), input_image_.length());
  }

  void ConvertPngToWebp(const GoogleString& png_image,
                        const WebpConfiguration& webp_config,
                        GoogleString* webp_image) {
    PngScanlineReaderRaw png_reader;
    // Initialize a PNG reader for reading the original image.
    ASSERT_TRUE(png_reader.Initialize(
        png_image.data(), png_image.length()));

    // Get the sizes and pixel format of the original image.
    const size_t width = png_reader.GetImageWidth();
    const size_t height = png_reader.GetImageHeight();
    const PixelFormat pixel_format = png_reader.GetPixelFormat();

    // WebP only supports RGB_888 and RGBA_8888.
    ASSERT_TRUE(pixel_format == RGB_888 || pixel_format == RGBA_8888);

    // Initialize the writer.
    WebpScanlineWriter webp_writer;
    ASSERT_TRUE(webp_writer.Init(width, height, pixel_format));
    ASSERT_TRUE(webp_writer.InitializeWrite(webp_config, webp_image));

    // Read the scanlines from the original image and write them to the new one.
    while (png_reader.HasMoreScanLines()) {
      uint8* scanline = NULL;
      ASSERT_TRUE(png_reader.ReadNextScanline(
          reinterpret_cast<void**>(&scanline)));
      ASSERT_TRUE(webp_writer.WriteNextScanline(
          reinterpret_cast<void*>(scanline)));
    }
    ASSERT_TRUE(webp_writer.FinalizeWrite());
  }

 protected:
  WebpScanlineReader reader_;
  GoogleString input_image_;
  void* scanline_;

 private:
  DISALLOW_COPY_AND_ASSIGN(WebpScanlineReaderTest);
};

// Verify that decoded image is accurate for each pixel. The WebP image is
// compressed in lossy format. The gold data is dynamically generated.
TEST_F(WebpScanlineReaderTest, ConvertToAndReadLossyWebp) {
  WebpConfiguration webp_config;
  webp_config.lossless = false;
  webp_config.quality = 90;

  for (size_t i = 0; i < kValidImageCount; ++i) {
    GoogleString png_image, webp_image;
    ReadTestFile(kWebpTestDir, kValidImages[i], "png", &png_image);
    ConvertPngToWebp(png_image, webp_config, &webp_image);
    DecodeAndCompareImagesByPSNR(IMAGE_PNG, png_image.c_str(),
                                 png_image.length(), IMAGE_WEBP,
                                 webp_image.c_str(), webp_image.length(),
                                 kMinPSNR);
  }
}

// Verify that decoded image is accurate for each pixel. The WebP image is
// compressed in lossless format.
TEST_F(WebpScanlineReaderTest, ConvertToAndReadLosslessWebp) {
  WebpConfiguration webp_config;
  webp_config.lossless = true;

  for (size_t i = 0; i < kValidImageCount; ++i) {
    GoogleString png_image, webp_image;
    ReadTestFile(kWebpTestDir, kValidImages[i], "png", &png_image);
    ConvertPngToWebp(png_image, webp_config, &webp_image);
    DecodeAndCompareImages(IMAGE_PNG, png_image.c_str(), png_image.length(),
                           IMAGE_WEBP, webp_image.c_str(),
                           webp_image.length());
  }
}

// Verify that decoded image is accurate for each pixel. The gold data was
// loaded from disk.
TEST_F(WebpScanlineReaderTest, CompareToWebpGolds) {
  WebpConfiguration webp_config;
  webp_config.lossless = true;

  for (size_t i = 0; i < kValidImageCount; ++i) {
    GoogleString png_image, webp_image;
    ReadTestFile(kWebpTestDir, kValidImages[i], "png", &png_image);
    ReadTestFile(kWebpTestDir, kValidImages[i], "webp", &webp_image);
    DecodeAndCompareImages(IMAGE_PNG, png_image.c_str(), png_image.length(),
                           IMAGE_WEBP, webp_image.c_str(), webp_image.length());
  }
}

TEST_F(WebpScanlineReaderTest, InitializeWithoutRead) {
  ASSERT_TRUE(Initialize(kValidImages[0]));
}

TEST_F(WebpScanlineReaderTest, ReadOneRow) {
  ASSERT_TRUE(Initialize(kValidImages[0]));
  ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
}

TEST_F(WebpScanlineReaderTest, ReinitializeAfterOneRow) {
  ASSERT_TRUE(Initialize(kValidImages[0]));
  ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
  ASSERT_TRUE(Initialize(kValidImages[1]));
  ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
}

TEST_F(WebpScanlineReaderTest, ReInitializeAfterLastRow) {
  ASSERT_TRUE(Initialize(kValidImages[0]));
  while (reader_.HasMoreScanLines()) {
    ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
  }
  ASSERT_FALSE(reader_.ReadNextScanline(&scanline_));
  ASSERT_TRUE(Initialize(kValidImages[1]));
  ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
}

TEST_F(WebpScanlineReaderTest, InvalidWebpHeader) {
  ASSERT_FALSE(Initialize(kFileCorruptedHeader));
}

TEST_F(WebpScanlineReaderTest, InvalidWebpBody) {
  ASSERT_TRUE(Initialize(kFileCorruptedBody));
  ASSERT_FALSE(reader_.ReadNextScanline(&scanline_));
}

}  // namespace
